---
date: 2021-11-05
tags: ["#SpringFramework/#SpringBoot"]
aliases: []
---

# Metadata

**Title** :: Java 基礎筆記模板

**Author** :: #Matthew 

**Classification** :: #Learn #Java #Basic #SpringFramework/#SpringBoot 

**Status** :: #🌱

**Type** :: #Note

**Previous** ::[[Study_Matthew/SpringBoot/2. SpringBoot 源碼剖析]]

**ParentNode** :: [[Study_Matthew/SpringBoot/SpringBoot]]

---

# 3.SpringBoot 數據訪問
## 3.1 數據源自動配置源碼剖析

### 數據源配置方式

1. 選擇數據庫驅動的庫文件
	
	在 maven 中配置數據庫驅動
	```xml
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
	</dependency>
	```

2. 配置數據庫連接
	在application.properties中配置數據庫連接
	```txt
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
	spring.datasource.url=jdbc:mysql:///springboot_h?
	useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
	spring.datasource.username=root
	spring.datasource.password=root
	# spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
	```

3. 配置spring-boot-starter-jdbc
	```xml
	<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
	</dependency>
	```

4. 編寫測試類
	```java
	@RunWith(SpringRunner.class)
	@SpringBootTest(classes = SpringBootMytestApplication.class)
	class SpringBootMytestApplicationTests {

		@Autowired
		DataSource dataSource;

		@Test
		public void contextLoads() throws SQLException {
			Connection connection = dataSource.getConnection();
		}
	}
	```


### 連接池配置方式

1. 選擇數據庫連接池的庫文件

SpringBoot提供了三種數據庫連接池：
- HikariCP
- Commons DBCP2
- Tomcat JDBC Connection Pool

其中spring boot2.x版本默認使用HikariCP，maven中配置如下：
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

如果不使用HikariCP，而改用Commons DBCP2，則配置如下：
```xml
<dependency>
	<groupId>org.apache.commons</groupId>
	<artifactId>commons-dbcp2</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
	<exclusions>
		<exclusion>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
		</exclusion>
	</exclusions>
</dependency>
```

如果不使用HikariCP，而改用Tomcat JDBC Connection Pool，則配置如下：
```xml
<dependency>
	<groupId>org.apache.tomcat</groupId>
	<artifactId>tomcat-jdbc</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
	<exclusions>
		<exclusion>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
		</exclusion>
	</exclusions>
</dependency>
```

思考：為什麼說springboot默認使用的連接池類型是HikariCP，在那指定的？



### 數據源自動配置
spring.factories中找到數據源的配置類：

![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109141120.png]]

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class,DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {
	
	@Configuration(proxyBeanMethods = false)
	@Conditional(EmbeddedDatabaseCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import(EmbeddedDataSourceConfiguration.class)
	protected static class EmbeddedDatabaseConfiguration {
	}
	
	@Configuration(proxyBeanMethods = false)
	@Conditional(PooledDataSourceCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import({ DataSourceConfiguration.Hikari.class,DataSourceConfiguration.Tomcat.class,DataSourceConfiguration.Dbcp2.class,DataSourceConfiguration.Generic.class,DataSourceJmxConfiguration.class })
	protected static class PooledDataSourceConfiguration {
	}
...

```

@Conditional(PooledDataSourceCondition.class) 根據判斷條件，實例化這個類，指定了配置文件中，必須有type這個屬性
![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109141332.png]]

另外springboot 默認支持 type 類型設置的數據源；
```java
@Import({ DataSourceConfiguration.Hikari.class,
	DataSourceConfiguration.Tomcat.class,
	DataSourceConfiguration.Dbcp2.class,
	DataSourceConfiguration.Generic.class,
	DataSourceJmxConfiguration.class })
```

```java
abstract class DataSourceConfiguration {
	DataSourceConfiguration() {
	}
	protected static <T> T createDataSource(DataSourceProperties properties,
	Class<? extends DataSource> type) {
		return properties.initializeDataSourceBuilder().type(type).build();
	}
	//自定义连接池 接口 spring.datasource.type 配置
	@ConditionalOnMissingBean({DataSource.class})
	@ConditionalOnProperty(
		name = {"spring.datasource.type"}
	)
	static class Generic {
		Generic() {
		}
		@Bean
		public DataSource dataSource(DataSourceProperties properties) {
			//创建数据源 initializeDataSourceBuilder DataSourceBuilder
			return properties.initializeDataSourceBuilder().build();
		}
	}
	//Dbcp2 连接池
	@ConditionalOnClass({BasicDataSource.class})
	@ConditionalOnMissingBean({DataSource.class})
	@ConditionalOnProperty(
		name = {"spring.datasource.type"},
		havingValue = "org.apache.commons.dbcp2.BasicDataSource",
		matchIfMissing = true
	)
	static class Dbcp2 {
		Dbcp2() {
		}
		
		@Bean
		@ConfigurationProperties(
			prefix = "spring.datasource.dbcp2"
		)
		public BasicDataSource dataSource(DataSourceProperties properties) {
		
			return (BasicDataSource)DataSourceConfiguration.createDataSource(properties, BasicDataSource.class);
		}
	}
	
	//2.0 之后默认默认使用 hikari 连接池
	@ConditionalOnClass({HikariDataSource.class})
	@ConditionalOnMissingBean({DataSource.class})
	@ConditionalOnProperty(
		name = {"spring.datasource.type"},
		havingValue = "com.zaxxer.hikari.HikariDataSource",
		matchIfMissing = true
	)
	static class Hikari {
		Hikari() {
		}
		@Bean
		@ConfigurationProperties(
			prefix = "spring.datasource.hikari"
		)
		public HikariDataSource dataSource(DataSourceProperties properties){
			HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);
			if (StringUtils.hasText(properties.getName())) {
				dataSource.setPoolName(properties.getName());
			}
			return dataSource;
		}
	}
	
	//2.0 之后默认不是使用 tomcat 连接池,或者使用tomcat 容器
	//如果导入tomcat jdbc连接池 则使用此连接池，在使用tomcat容器时候 或者导入此包时候
	@ConditionalOnClass({org.apache.tomcat.jdbc.pool.DataSource.class})
	@ConditionalOnMissingBean({DataSource.class})
	//并且配置的配置是 org.apache.tomcat.jdbc.pool.DataSource 会采用tomcat 连接池
	@ConditionalOnProperty(
		name = {"spring.datasource.type"}, //name用来从application.properties中读取某个属性值
		havingValue = "org.apache.tomcat.jdbc.pool.DataSource",
		//缺少该property时是否可以加载。如果为true，没有该property也会正常加载；反之	报错
		//不管你配不配置 都以 tomcat 连接池作为连接池
		matchIfMissing = true //默认是false
	)
	
	static class Tomcat {
		Tomcat() {
		}
		//给容器中加数据源
		@Bean
		@ConfigurationProperties(
			prefix = "spring.datasource.tomcat"
		)
		public org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties) {
		org.apache.tomcat.jdbc.pool.DataSource dataSource =	
			(org.apache.tomcat.jdbc.pool.DataSource)DataSourceConfiguration.createDataSource(properties, org.apache.tomcat.jdbc.pool.DataSource.class);
		DatabaseDriver databaseDriver =	
			DatabaseDriver.fromJdbcUrl(properties.determineUrl());
			
		String validationQuery = databaseDriver.getValidationQuery();
			
		if (validationQuery != null) {
			dataSource.setTestOnBorrow(true);
			dataSource.setValidationQuery(validationQuery);
		}
		return dataSource;
		}
	}
}
```

如果在類路徑沒有找到 jar包 則會跑出異常

Field dataSource in com.example.springsession.demo.jpa.StudentController required a bean of type ‘javax.sql.DataSource’ that could not be found.
-Bean method ‘dataSource’ not loaded because @ConditionalOnClass did not find required
class ‘org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType’

- Bean method ‘dataSource’ not loaded because @ConditionalOnClass did not findrequired classes ‘javax.transaction.TransactionManager’, ‘org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType’

DataSourceConfiguration

配置文件中沒有指定數據源時候 會根據註解判斷然後選擇相應的實例化數據源對象！則 type 為空。
```java
@ConditionalOnClass({HikariDataSource.class})
@ConditionalOnMissingBean({DataSource.class}) //注解判断是否执行初始化代码，即如
果用户已经创建了bean，则相关的初始化代码不再执行
@ConditionalOnProperty(
	name = {"spring.datasource.type"}, //拿配置文件中的type 如果为空返回fale
	havingValue = "com.zaxxer.hikari.HikariDataSource", //type 不为空则去
	havingValue 对比 ，相同则ture 否则为false
	matchIfMissing = true // 不管上面文件中是否配置，默认都进行加载，matchIfMissing的默值为false
)
static class Hikari {
	Hikari() {
	}
	@Bean
	@ConfigurationProperties(
		prefix = "spring.datasource.hikari"
	)
	public HikariDataSource dataSource(DataSourceProperties properties) {
	//创建数据源
	HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);
		if (StringUtils.hasText(properties.getName())) {
			dataSource.setPoolName(properties.getName());
		}
		return dataSource;
	}
```

createDataSource 方法
```java
protected static <T> T createDataSource(DataSourceProperties properties, Class<? extends DataSource> type) {
	// 使用DataSourceBuilder 建造数据源，利用反射创建type数据源，然后绑定相关属性
	return properties.initializeDataSourceBuilder().type(type).build();
}
```

DataSourceBuilder 類

設置type
```java
public <D extends DataSource> DataSourceBuilder<D> type(Class<D> type) {
	this.type = type;
	return this;
}
```

根據設置type的選擇類型
```java
private Class<? extends DataSource> getType() {
	//如果没有配置type 则为空 默认选择 findType
	Class<? extends DataSource> type = this.type != null ? this.type :
	findType(this.classLoader);
	if (type != null) {
		return type;
	} else {
		throw new IllegalStateException("No supported DataSource type found");
	}
}
```

```java
public static Class<? extends DataSource> findType(ClassLoader classLoader){
	String[] var1 = DATA_SOURCE_TYPE_NAMES;
	int var2 = var1.length;
	int var3 = 0;
	while(var3 < var2) {
		String name = var1[var3];
		try {
			return ClassUtils.forName(name, classLoader);
		} catch (Exception var6) {
			++var3;
		}
	}
	return null;
}
```

//數組
```java
private static final String[] DATA_SOURCE_TYPE_NAMES = new String[]
{"com.zaxxer.hikari.HikariDataSource",
"org.apache.tomcat.jdbc.pool.DataSource",
"org.apache.commons.dbcp2.BasicDataSource"};
```

取出來的第一個值就是com.zaxxer.hikari.HikariDataSource，那麼證實在沒有指定Type的情況下，默認類型為com.zaxxer.hikari.HikariDataSource



## 3.2 Druid連接池的配置

### 整合效果實現
1. 在pom.xml中引入druid數據源
	```xml
	<dependency>
		<groupId>com.alibaba</groupId>
		<artifactId>druid-spring-boot-starter</artifactId>
		<version>1.1.10</version>
	</dependency>
	```

2. 在application.yml中引入druid的相關配置
	```yml
	spring:
		datasource:
			username: root
			password: root
			url: jdbc:mysql:///springboot_h?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=UTC
			driver-class-name: com.mysql.cj.jdbc.Driver
			initialization-mode: always
			# 使用druid数据源
			type: com.alibaba.druid.pool.DruidDataSource
			# 数据源其他配置
			initialSize: 5
			minIdle: 5
			maxActive: 20
			maxWait: 60000
			timeBetweenEvictionRunsMillis: 60000
			minEvictableIdleTimeMillis: 300000
			validationQuery: SELECT 1 FROM DUAL
			testWhileIdle: true
			testOnBorrow: false
			testOnReturn: false
			poolPreparedStatements: true
			# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
			filters: stat,wall,log4j
			maxPoolPreparedStatementPerConnectionSize: 20
			useGlobalDataSourceStat: true
			connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
	```

	進行測試：
	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109143455.png]]

	但是Dubug查看DataSource的值，會發現有些屬性是沒有生效的
	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109143515.png]]

	這是因為：如果單純在yml文件中編寫如上的配置，SpringBoot肯定是讀取不到druid的相關配置的。因為它並不像我們原生的jdbc，系統默認就使用DataSourceProperties與其屬性進行了綁定。所以我們應該編寫一個類與其屬性進行綁定

3. 編寫整合druid的配置類DruidConfig
	```java
	public class DruidConfig {
		@ConfigurationProperties(prefix = "spring.datasource")
		@Bean
		public DataSource druid(){
			return new DruidDataSource();
		}
	}
	```

	測試的時候，突然發現控制台報錯了。經過查找發現是yml文件裡的
	```log
	filters: stat,wall,log4j
	```

	因為我們springBoot2.0以後使用的日誌框架已經不再使用log4j了。此時應該引入相應的適配器。
	我們可以在pom.xml文件上加入
	```xml
	<!--引入適配器-->
	<dependency>
		<groupId>org.slf4j</groupId>
		<artifactId>slf4j-log4j12</artifactId>
	</dependency>
	```
	這時進行相關測試就可以了


## 3.3 SpringBoot整合Mybatis
 MyBatis 是一款優秀的持久層框架，Spring Boot官方雖然沒有對MyBatis進行整合，但是MyBatis團隊自行適配了對應的啟動器，進一步簡化了使用MyBatis進行數據的操作 
 
 因為Spring Boot框架開發的便利性，所以實現Spring Boot與數據訪問層框架（例如MyBatis）的整合非常簡單，主要是引入對應的依賴啟動器，並進行數據庫相關參數設置即可

### 整合效果實現
1. 新建springboot項目，並導入mybatis的pom配置
	```xml
	<!-- 配置数据库驱动和mybatis dependency -->
	<dependency>
		<groupId>org.mybatis.spring.boot</groupId>
		<artifactId>mybatis-spring-boot-starter</artifactId>
		<version>1.3.2</version>
	</dependency>

	<dependency>
		<groupId>org.projectlombok</groupId>
		<artifactId>lombok</artifactId>
		<optional>true</optional>
	</dependency>
	```

	```yml
	application.yml配置

	spring:
		datasource:
		username: root
		password: root
		url: jdbc:mysql:///springboot_h?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=UTC
		driver-class-name: com.mysql.jdbc.Driver
		# 使用druid数据源
		type: com.alibaba.druid.pool.DruidDataSource
	```

2. 基礎類（使用lombok自動生成get/set方法）
	```java
	package com.lagou.demo.domain;

	import lombok.Data;

	@Data
	public class User {
		private Integer id;
		private String username;
		private Integer age;
	}
	```

3. 測試dao（mybatis使用註解開發）
	```java
	package com.lagou.dao;

	import com.lagou.pojo.User;
	import org.apache.ibatis.annotations.Mapper;
	import org.apache.ibatis.annotations.Select;

	@Mapper
	public interface UserDao {
		@Select("SELECT * FROM USER")
		List<User> getUser();
	}
	```

4. 測試service
	```java
	package com.example.demo.service;

	import com.example.demo.dao.UserDao;
	import com.example.demo.domain.User;
	import lombok.extern.slf4j.Slf4j;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Service;
	import java.util.List;

	@Service
	public class UserService {
		Logger logger = LoggerFactory.getLogger(UserService.class);

		@Autowired
		private UserDao userDao;

		public List<User> getUser(){
			List<User> userList = userDao.getUser();
			logger.info("查询出来的用户信息，{}",userList.toString());
			return userList;
		}
	}
	```

5. service對應的test類（該測試類繼承主測試類（主測試類直接在啟動文件上goto test即可自動生成））
	```java
	package com.example.demo.service;

	import com.example.demo.DemoApplicationTests;
	import org.junit.Test;
	import org.junit.runner.RunWith;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.context.SpringBootTest;
	import static org.junit.Assert.*;

	public class UserServiceTest extends DemoApplicationTests {
		@Autowired
		private UserService userService;
		@Test
		public void getUser() {
			userService.getUser();
		}
	}
	```

	```java
	package com.example.demo;
	import org.junit.Test;
	import org.junit.runner.RunWith;
	import org.springframework.boot.test.context.SpringBootTest;
	import org.springframework.test.context.junit4.SpringRunner;

	@RunWith(SpringRunner.class)
	@SpringBootTest
	public class DemoApplicationTests {
		@Test
		public void contextLoads() {
		}
	}
	```

6. 運行測試類輸出結果
	
	查詢出來的用戶信息，[User(id=1, username=test, age=11)]



## 3.4 Mybatis自動配置源碼分析

1. springboot項目最核心的就是自動加載配置，該功能則依賴的是一個註解@SpringBootApplication中的@EnableAutoConfiguration
	
2. EnableAutoConfiguration主要是通過AutoConfigurationImportSelector類來加載
	
	以mybatis為例，*selector通過反射加載spring.factories中指定的java類，也就是加載MybatisAutoConfiguration類（該類有Configuration註解，屬於配置類）

	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109145353.png]]
	
	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109145403.png]]
	
	```java
	/**
	* {@link EnableAutoConfiguration Auto-Configuration} for Mybatis.
	Contributes a 重点：SqlSessionFactory 和 SqlSessionTemplate 两个类
	* {@link SqlSessionFactory} and a {@link SqlSessionTemplate}.
	*
	* If {@link org.mybatis.spring.annotation.MapperScan} is used, or a
	* configuration file is specified as a property, those will be considered,
	* otherwise this auto-configuration will attempt to register mappers based
	on
	* the interface definitions in or under the root auto-configuration
	package.
	*
	* @author Eddú Meléndez
	* @author Josh Long
	* @author Kazuki Shimizu
	* @author Eduardo Macarrón
	*/
	@org.springframework.context.annotation.Configuration
	@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})
	@ConditionalOnBean(DataSource.class)
	@EnableConfigurationProperties(MybatisProperties.class)
	@AutoConfigureAfter(DataSourceAutoConfiguration.class)
	public class MybatisAutoConfiguration {
		private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);
		// //与mybatis配置文件对应
		private final MybatisProperties properties;
		private final Interceptor[] interceptors;
		private final ResourceLoader resourceLoader;
		private final DatabaseIdProvider databaseIdProvider;
		private final List<ConfigurationCustomizer> configurationCustomizers;
		public MybatisAutoConfiguration(MybatisProperties properties,
		ObjectProvider<Interceptor[]>
		interceptorsProvider,
		ResourceLoader resourceLoader,
		ObjectProvider<DatabaseIdProvider>
		databaseIdProvider,
		ObjectProvider<List<ConfigurationCustomizer>>
		configurationCustomizersProvider) {
		this.properties = properties;
		this.interceptors = interceptorsProvider.getIfAvailable();
		this.resourceLoader = resourceLoader;
		this.databaseIdProvider = databaseIdProvider.getIfAvailable();
		this.configurationCustomizers =
		configurationCustomizersProvider.getIfAvailable();
	}
		
	//postConstruct作用是在创建类的时候先调用， 校验配置文件是否存在
	@PostConstruct
	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation() &&
		StringUtils.hasText(this.properties.getConfigLocation())) {
		Resource resource =	this.resourceLoader.getResource(this.properties.getConfigLocation());
		Assert.state(resource.exists(), "Cannot find config location: " + resource + " (please add config file or check your Mybatis			configuration)");
		}
	}
		
	//conditionalOnMissingBean作用：在没有类的时候调用，创建sqlsessionFactory sqlsessionfactory最主要的是创建并保存了Configuration类
	@Bean
	@ConditionalOnMissingBean
	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfigLocation())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
		}
		Configuration configuration = this.properties.getConfiguration();
		if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
			configuration = new Configuration();
		}
		if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
			for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
				customizer.customize(configuration);
			}
		}
		factory.setConfiguration(configuration);
		if (this.properties.getConfigurationProperties() != null) {
			factory.setConfigurationProperties(this.properties.getConfigurationProperties());
		}
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}
		// //获取SqlSessionFactoryBean的getObject()中的对象注入Spring容器，也就是 SqlSessionFactory对象
		return factory.getObject();
	}
		
	@Bean
	@ConditionalOnMissingBean
	// 往Spring容器中注入SqlSessionTemplate对象
	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);
		} else {
			return new SqlSessionTemplate(sqlSessionFactory);
		}
	}
	```

3. MybatisAutoConfiguration：
	
	①類中有個MybatisProperties類，該類對應的是mybatis的配置文件

	②類中有個sqlSessionFactory方法，作用是創建SqlSessionFactory類、Configuration類（mybatis最主要的類，保存著與mybatis相關的東西）

	③SelSessionTemplate，作用是與mapperProoxy代理類有關

	sqlSessionFactory主要是通過創建了一個SqlSessionFactoryBean，這個類實現了FactoryBean接口，所以在Spring容器就會注入這個類中定義的getObject方法返回的對象。

	看一下getObject()方法做了什麼？

	```java
	@Override
	public SqlSessionFactory getObject() throws Exception {
		if (this.sqlSessionFactory == null) {
		afterPropertiesSet();
		}
		return this.sqlSessionFactory;
		}
		@Override
		public void afterPropertiesSet() throws Exception {
			
		notNull(dataSource, "Property 'dataSource' is required");
		notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required");
			
		state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),
		"Property 'configuration' and 'configLocation' can not specified with together");
			
		this.sqlSessionFactory = buildSqlSessionFactory();
	}
	```

	```java
	protected SqlSessionFactory buildSqlSessionFactory() throws Exception {
		final Configuration targetConfiguration;
		XMLConfigBuilder xmlConfigBuilder = null;
		if (this.configuration != null) {
			targetConfiguration = this.configuration;
			if (targetConfiguration.getVariables() == null) {
				targetConfiguration.setVariables(this.configurationProperties);
			} else if (this.configurationProperties != null) {
				targetConfiguration.getVariables().putAll(this.configurationProperties);
			}
		} else if (this.configLocation != null) {
			xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);
			targetConfiguration = xmlConfigBuilder.getConfiguration();
		} else {
			LOGGER.debug(
			() -> "Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration");
			targetConfiguration = new Configuration();
			Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);
		}
		Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);
		Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);
		Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);
		
		if (hasLength(this.typeAliasesPackage)) {
			scanClasses( this.typeAliasesPackage, this.typeAliasesSuperType)
							.stream()
							.filter(clazz -> !clazz.isAnonymousClass())
							.filter(clazz -> !clazz.isInterface())
							.filter(clazz -> !clazz.isMemberClass())
							.forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);
		}
		
		if (!isEmpty(this.typeAliases)) {
			Stream.of(this.typeAliases).forEach(typeAlias -> {
				targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);
				LOGGER.debug(() -> "Registered type alias: '" + typeAlias + "'");
			});
		}
		
		if (!isEmpty(this.plugins)) {
			Stream.of(this.plugins).forEach(plugin -> {
				targetConfiguration.addInterceptor(plugin);
				LOGGER.debug(() -> "Registered plugin: '" + plugin + "'");
			});
		}
		
		if (hasLength(this.typeHandlersPackage)) {
			scanClasses(this.typeHandlersPackage, TypeHandler.class)
				.stream()
				.filter(clazz -> !clazz.isAnonymousClass())
				.filter(clazz -> !clazz.isInterface())
				.filter(clazz -> !Modifier.isAbstract(clazz.getModifiers()))
				.forEach(targetConfiguration.getTypeHandlerRegistry()::register);
		}
		
		if (!isEmpty(this.typeHandlers)) {
			Stream.of(this.typeHandlers).forEach(typeHandler -> {
				targetConfiguration.getTypeHandlerRegistry().register(typeHandler);
				LOGGER.debug(() -> "Registered type handler: '" + typeHandler +	"'");
			});
		}
		
		targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);
		
		if (!isEmpty(this.scriptingLanguageDrivers)) {
			Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -> {
				targetConfiguration.getLanguageRegistry().register(languageDriver);
				LOGGER.debug(() -> "Registered scripting language driver: '" + languageDriver + "'");
			});
		}
		
		Optional.ofNullable(this.defaultScriptingLanguageDriver).ifPresent(targetConfiguration::setDefaultScriptingLanguage);
		
		if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls
			try {
			targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(thi
			s.dataSource));
			} catch (SQLException e) {
			throw new NestedIOException("Failed getting a databaseId", e);
			}
		}
		
		Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);
		
		if (xmlConfigBuilder != null) {
			try {
				xmlConfigBuilder.parse();
				LOGGER.debug(() -> "Parsed configuration file: '" +
				this.configLocation + "'");
			} catch (Exception ex) {
				throw new NestedIOException("Failed to parse config resource: " +
				this.configLocation, ex);
			} finally {
				ErrorContext.instance().reset();
			}
		}
		
		targetConfiguration.setEnvironment(
			
			new Environment(
				this.environment,this.transactionFactory == null ? 
				new SpringManagedTransactionFactory() : 
				this.transactionFactory,
				this.dataSource));
		
			if (this.mapperLocations != null) {
				if (this.mapperLocations.length == 0) {
					LOGGER.warn(() -> "Property 'mapperLocations' was specified but matching resources are not found.");
				} else {
					for (Resource mapperLocation : this.mapperLocations) {
						if (mapperLocation == null) {
							continue;
						}
						try {
							XMLMapperBuilder xmlMapperBuilder = new
							XMLMapperBuilder(mapperLocation.getInputStream(),
							targetConfiguration, mapperLocation.toString(),
							targetConfiguration.getSqlFragments());
							//这个方法已经是mybaits的源码，初始化流程
							xmlMapperBuilder.parse();
						} catch (Exception e) {
							throw new NestedIOException("Failed to parse mapping resource: '" + mapperLocation + "'", e);
						} finally {
							ErrorContext.instance().reset();
						}
						LOGGER.debug(() -> "Parsed mapper file: '" + mapperLocation + "'");
					}
				}
			} else {
				LOGGER.debug(() -> "Property 'mapperLocations' was not specified.");
			}
			//这个方法已经是mybaits的源码，初始化流程
			return this.sqlSessionFactoryBuilder.build(targetConfiguration);
		}
	```

	這個已經很明顯了，實際上就是調用了MyBatis的初始化流程

	現在已經得到了SqlSessionFactory了，接下來就是如何掃描到相關的Mapper接口了。
	
	這個需要看這個註解
	
	@MapperScan(basePackages = “com.mybatis.mapper”)

	```java
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.TYPE)
	@Documented
	@Import(MapperScannerRegistrar.class)
	@Repeatable(MapperScans.class)
	public @interface MapperScan
	```

	通過@Import的方式會掃描到MapperScannerRegistrar類。
	
	MapperScannerRegistrar實現了ImportBeanDefinitionRegistrar接口，那麼在spring實例化之前就會調用到registerBeanDefinitions方法

	```java
	public class MapperScannerRegistrar implements
	ImportBeanDefinitionRegistrar, ResourceLoaderAware
	```

	```java
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		//拿到MapperScan注解，并解析注解中定义的属性封装成AnnotationAttributes对象
		AnnotationAttributes mapperScanAttrs = AnnotationAttributes
		.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
		
		if (mapperScanAttrs != null) {
			registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,
			generateBaseBeanName(importingClassMetadata, 0));
		}
	}

	void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) {
		
		BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
		builder.addPropertyValue("processPropertyPlaceHolders", true);
		
		Class<? extends Annotation> annotationClass = annoAttrs.getClass("annotationClass");
		if (!Annotation.class.equals(annotationClass)) {
			builder.addPropertyValue("annotationClass", annotationClass);
		}
		
		Class<?> markerInterface = annoAttrs.getClass("markerInterface");
		if (!Class.class.equals(markerInterface)) {
			builder.addPropertyValue("markerInterface", markerInterface);
		}
		
		Class<? extends BeanNameGenerator> generatorClass = annoAttrs.getClass("nameGenerator");
		if (!BeanNameGenerator.class.equals(generatorClass)) {
			builder.addPropertyValue("nameGenerator", BeanUtils.instantiateClass(generatorClass));
		}
		
		Class<? extends MapperFactoryBean> mapperFactoryBeanClass = annoAttrs.getClass("factoryBean");
		if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {
			builder.addPropertyValue("mapperFactoryBeanClass", mapperFactoryBeanClass);
		}
		
		String sqlSessionTemplateRef = annoAttrs.getString("sqlSessionTemplateRef");
		if (StringUtils.hasText(sqlSessionTemplateRef)) {
			builder.addPropertyValue("sqlSessionTemplateBeanName", annoAttrs.getString("sqlSessionTemplateRef"));
		}
		
		String sqlSessionFactoryRef = annoAttrs.getString("sqlSessionFactoryRef");
			if (StringUtils.hasText(sqlSessionFactoryRef)) {
			builder.addPropertyValue("sqlSessionFactoryBeanName", annoAttrs.getString("sqlSessionFactoryRef"));
		}
		
		List<String> basePackages = new ArrayList<>();
		
		basePackages.addAll(
		Arrays.stream(annoAttrs.getStringArray("value")).filter(StringUtils::hasText).collect(Collectors.toList()));
		
		basePackages.addAll(Arrays.stream(annoAttrs.getStringArray("basePackages"))
			.filter(StringUtils::hasText)
			.collect(Collectors.toList()));
		
		basePackages.addAll(Arrays.stream(annoAttrs.getClassArray("basePackageClasses"))
			.map(ClassUtils::getPackageName)
			.collect(Collectors.toList()));
		
		if (basePackages.isEmpty()) {
			basePackages.add(getDefaultBasePackage(annoMeta));
		}
		
		String lazyInitialization = annoAttrs.getString("lazyInitialization");
		if (StringUtils.hasText(lazyInitialization)) {
			builder.addPropertyValue("lazyInitialization", lazyInitialization);
		}
		
		builder.addPropertyValue("basePackage", StringUtils.collectionToCommaDelimitedString(basePackages));
		//把类型为MapperScannerConfigurer的注册到spring容器中
		registry.registerBeanDefinition(beanName, builder.getBeanDefinition());
	}
	```

	MapperScannerConfigurer實現了BeanDefinitionRegistryPostProcessor接口，所以接著又會掃描並調用到postProcessBeanDefinitionRegistry方法。

	```java
	public class MapperScannerConfigurer
	implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware
	```

	```java
	@Override
	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
		if (this.processPropertyPlaceHolders) {
			processPropertyPlaceHolders();
		}
		ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
		scanner.setAddToConfig(this.addToConfig);
		scanner.setAnnotationClass(this.annotationClass);
		scanner.setMarkerInterface(this.markerInterface);
		scanner.setSqlSessionFactory(this.sqlSessionFactory);
		scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
		scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
		scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
		scanner.setResourceLoader(this.applicationContext);
		scanner.setBeanNameGenerator(this.nameGenerator);
		scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);
		if (StringUtils.hasText(lazyInitialization)) {
			scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
		}
		scanner.registerFilters();
		scanner.scan(
			StringUtils.tokenizeToStringArray(this.basePackage,
			ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)
		);
	}
	```

	```java
	public int scan(String... basePackages) {
		int beanCountAtScanStart = this.registry.getBeanDefinitionCount();
		doScan(basePackages);
		// Register annotation config processors, if necessary.
		if (this.includeAnnotationConfig) {
			AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
		}
		return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
	}
	```

	```java
	@Override
	public Set<BeanDefinitionHolder> doScan(String... basePackages) {
		//这个方法主要就注册扫描basePackages路径下的mapper接口，然后封装成一个
		BeanDefinition后加入到spring容器中
		Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);
		if (beanDefinitions.isEmpty()) {
			LOGGER.warn(() -> "No MyBatis mapper was found in '" + Arrays.toString(basePackages) + "' package. Please check your configuration.");
		} else {
			//这个方法主要会把原BeanDefinition的beanClass类型，修改为MapperFactoryBean
			processBeanDefinitions(beanDefinitions);
		}
		return beanDefinitions;
	}
	```

	修改了mapper的beanClass類型為MapperFactoryBean
	
	```java
	private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {
		GenericBeanDefinition definition;
		for (BeanDefinitionHolder holder : beanDefinitions) {
			definition = (GenericBeanDefinition) holder.getBeanDefinition();
			String beanClassName = definition.getBeanClassName();
			LOGGER.debug(() -> "Creating MapperFactoryBean with name '" + holder.getBeanName() + "' and '" + beanClassName + "' mapperInterface");
			// the mapper interface is the original class of the bean
			// but, the actual class of the bean is MapperFactoryBean
			definition.getConstructorArgumentValues().addGenericArgumentValue(beanClass Name); // issue #59
			
			//修改beanClass类型
			definition.setBeanClass(this.mapperFactoryBeanClass);
			definition.getPropertyValues().add("addToConfig", this.addToConfig);
			boolean explicitFactoryUsed = false;
			if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) {
				definition.getPropertyValues().add("sqlSessionFactory",
				new RuntimeBeanReference(this.sqlSessionFactoryBeanName));
				explicitFactoryUsed = true;
			} else if (this.sqlSessionFactory != null) {
				definition.getPropertyValues().add("sqlSessionFactory",
				this.sqlSessionFactory);
				explicitFactoryUsed = true;
			}
			if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) {
				if (explicitFactoryUsed) {
					LOGGER.warn(
						() -> "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."
					);
				}
				definition.getPropertyValues().add("sqlSessionTemplate",
				new RuntimeBeanReference(this.sqlSessionTemplateBeanName));
				explicitFactoryUsed = true;
			} else if (this.sqlSessionTemplate != null) {
				if (explicitFactoryUsed) {
					LOGGER.warn(
						() -> "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.");
				}
				definition.getPropertyValues().add("sqlSessionTemplate",
				this.sqlSessionTemplate);
				explicitFactoryUsed = true;
			}
			
			if (!explicitFactoryUsed) {
				LOGGER.debug(() -> "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'.");
				definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
			}
							 
			definition.setLazyInit(lazyInitialization);
							 
		}
	}
	```

**上述幾步主要是完成通過**

**@MapperScan(basePackages = “com.mybatis.mapper”)這個定義，掃描指定包下的mapper接口，然後設置每個mapper接口的beanClass屬性為MapperFactoryBean類型並加入到spring的bean容器中。**

MapperFactoryBean實現了FactoryBean接口，所以當spring從待實例化的bean容器中遍歷到這個bean並開始執行實例化時返回的對象實際上是getObject方法中返回的對象。

```java
public class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T>
```

最後看一下MapperFactoryBean的getObject方法，實際上返回的就是mybatis中通過getMapper拿到的對象，熟悉mybatis源碼的就應該清楚，這個就是mybatis通過動態代理生成的mapper接口實現類'

```java
@Override public T getObject() throws Exception { return getSqlSession().getMapper(this.mapperInterface); }
```

到此，mapper接口現在也通過動態代理生成了實現類，並且注入到spring的bean容器中了，之後使用者就可以通過@Autowired或者getBean等方式，從spring容器中獲取到了



## 3.5 SpringBoot + Mybatis實現動態數據源切換

### 動態數據源介紹

#### 業務背景
電商訂單項目分正向和逆向兩個部分：其中正向數據庫記錄了訂單的基本信息，包括訂單基本信息、訂單商品信息、優惠卷信息、發票信息、賬期信息、結算信息、訂單備註信息、收貨人信息等；逆向數據庫主要包含了商品的退貨信息和維修信息。數據量超過500萬行就要考慮分庫分錶和讀寫分離，那麼我們在正向操作和逆向操作的時候，就需要動態的切換到相應的數據庫，進行相關的操作。

#### 解決思路
現在項目的結構設計基本上是基於MVC的，那麼數據庫的操作集中在dao層完成，主要業務邏輯在service層處理，controller層處理請求。假設在執行dao層代碼之前能夠將數據源（DataSource）換成我們想要執行操作的數據源，那麼這個問題就解決了

#### 原理圖
![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109160329.png]]

Spring內置了一個AbstractRoutingDataSource，它可以把多個數據源配置成一個Map，然後，根據不同的key返回不同的數據源。因為AbstractRoutingDataSource也是一個DataSource接口，因此，應用程序可以先設置好key， 訪問數據庫的代碼就可以從AbstractRoutingDataSource拿到對應的一個真實的數據源，從而訪問指定的數據庫

查看AbstractRoutingDataSource類：
```java
/**
* Abstract {@link javax.sql.DataSource} implementation that routes {@link
#getConnection()}
* calls to one of various target DataSources based on a lookup key. The
latter is usually
* (but not necessarily) determined through some thread-bound transaction
context.
*
* @author Juergen Hoeller
* @since 2.0.1
* @see #setTargetDataSources
* @see #setDefaultTargetDataSource
* @see #determineCurrentLookupKey()
*/
//翻译结果如下
/**
* 抽象 {@link javax.sql.DataSource} 路由 {@link #getConnection ()} 的实现
* 根据查找键调用不同的目标数据之一。后者通常是
* (但不一定) 通过某些线程绑定事务上下文来确定。
*
* @author
* @since 2.0。1
* @see #setTargetDataSources
* @see #setDefaultTargetDataSource
* @see #determineCurrentLookupKey ()
*/
public abstract class AbstractRoutingDataSource extends AbstractDataSource
implements InitializingBean {
.......
/**
* Specify the map of target DataSources, with the lookup key as key.
* The mapped value can either be a corresponding {@link
javax.sql.DataSource}
* instance or a data source name String (to be resolved via a
* {@link #setDataSourceLookup DataSourceLookup}).
* <p>The key can be of arbitrary type; this class implements the
* generic lookup process only. The concrete key representation will
* be handled by {@link #resolveSpecifiedLookupKey(Object)} and
* {@link #determineCurrentLookupKey()}.
*/
//翻译如下
/**
*指定目标数据源的映射，查找键为键。
*映射的值可以是相应的{@link javax.sql.DataSource}
*实例或数据源名称字符串（要通过
* {@link #setDataSourceLookup DataSourceLookup}）。
*键可以是任意类型的; 这个类实现了
*通用查找过程只。 具体的关键表示将
*由{@link #resolveSpecifiedLookupKey（Object）}和
* {@link #determineCurrentLookupKey（）}。
*/
	public void setTargetDataSources(Map<Object, Object> targetDataSources){
		this.targetDataSources = targetDataSources;
	}
......
/**
* Determine the current lookup key. This will typically be
* implemented to check a thread-bound transaction context.
* <p>Allows for arbitrary keys. The returned key needs
* to match the stored lookup key type, as resolved by the
* {@link #resolveSpecifiedLookupKey} method.
*/
//翻译如下
/**
* 确定当前的查找键。这通常会
* 实现以检查线程绑定的事务上下文。
* <p> 允许任意键。返回的密钥需要
* 与存储的查找密钥类型匹配, 如
* {@link #resolveSpecifiedLookupKey} 方法。
*/
	protected abstract Object determineCurrentLookupKey();
}
```

上面源碼中還有另外一個核心的方法 setTargetDataSources(Map<Object, Object>targetDataSources) ，它需要一個Map，在方法註釋中我們可以得知，這個Map存儲的就是我們配置的多個數據源的鍵值對。我們整理一下這個類切換數據源的運作方式，這個類在連接數據庫之前會執行determineCurrentLookupKey()方法，這個方法返回的數據將作為key去targetDataSources中查找相應的值，如果查找到相對應的DataSource，那麼就使用此DataSource獲取數據庫連接

它是一個abstract類，所以我們使用的話，推薦的方式是創建一個類來繼承它並且實現它的determineCurrentLookupKey() 方法，這個方法介紹上面也進行了說明，就是通過這個方法進行數據源的切換

#### 環境準備：
1. 實體類
	```java
	public class Product {
		private Integer id;
		private String name;
		private Double price;
		public Integer getId() {
		    return id;
		}
		public void setId(Integer id) {
		    this.id = id;
		}
		public String getName() {
		    return name;
		}
		public void setName(String name) {
		    this.name = name;
		}
		public Double getPrice() {
		    return price;
		}
		public void setPrice(Double price) {
		    this.price = price;
		}
		@Override
		public String toString() {
		    return "Product{" +
		        "id=" + id +
		        ", name='" + name + '\'' +
		        ", price=" + price +
		        '}';
		}
	}

	```

2. ProductMapper
	```java
	public interface ProductMapper {
		
		@Select("select * from product")
		public List<Product> findAllProductM();
		
		@Select("select * from product")
		public List<Product> findAllProductS();
		
	}
	```

3. ProductService
	```java
	@Service
		public class ProductService {
		@Autowired
		private ProductMapper productMapper;
		public void findAllProductM(){
			// 查询Master
			List<Product> allProductM = productMapper.findAllProductM();
			System.out.println(allProductM);
		}
		public void findAllProductS(){
			// 查询Slave
			List<Product> allProductS = productMapper.findAllProductS();
			System.out.println(allProductS);
		}
	}
	```

4. ProductController
	```java
	@RestController
	public class ProductController {
		@Autowired
		private ProductService productService;
		
		@GetMapping("/findAllProductM")
		public String findAllProductM() {
			productService.findAllProductM();
			return "master";
		}
		
		@GetMapping("/findAllProductS")
		public String findAllProductS() {
			productService.findAllProductS();
			return "slave";
		}
	```

#### 具體實現
##### 第一步：配置多數據源
首先，我們在application.properties中配置兩個數據源
```properties
spring.druid.datasource.master.password=root
spring.druid.datasource.master.username=root
spring.druid.datasource.master.jdbcurl=jdbc:mysql://localhost:3306/product_master?
useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
spring.druid.datasource.master.driver-class-name=com.mysql.cj.jdbc.Driver
spring.druid.datasource.slave.password=root
spring.druid.datasource.slave.username=root
spring.druid.datasource.slave.jdbcurl=jdbc:mysql://localhost:3306/product_slave?
useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
spring.druid.datasource.slave.driver-class-name=com.mysql.cj.jdbc.Driver
```

在SpringBoot的配置代碼中，我們初始化兩個數據源：
```java
@Configuration
public class MyDataSourceConfiguratioin {
	Logger logger = LoggerFactory.getLogger(MyDataSourceConfiguratioin.class);
	/**
	* Master data source.
	*/
	@Bean("masterDataSource")
	@ConfigurationProperties(prefix = "spring.druid.datasource.master")
	DataSource masterDataSource() {
		logger.info("create master datasource...");
		return DataSourceBuilder.create().build();
	}
	/**
	* Slave data source.
	*/
	@Bean("slaveDataSource")
	@ConfigurationProperties(prefix = "spring.druid.datasource.slave")
	DataSource slaveDataSource() {
		logger.info("create slave datasource...");
		return DataSourceBuilder.create().build();
	}
}
```

##### 第二步：編寫RoutingDataSource
然後，我們用Spring內置的RoutingDataSource，把兩個真實的數據源代理為一個動態數據源:
```java
public class RoutingDataSource extends AbstractRoutingDataSource {
	@Override
	protected Object determineCurrentLookupKey() {
		return "masterDataSource";
	}
}
```

,對這個 RoutingDataSource ，需要在SpringBoot中配置好並設置為主數據源：
```java
@Bean
@Primary
DataSource primaryDataSource(
@Autowired @Qualifier("masterDataSource") DataSource
masterDataSource,
@Autowired @Qualifier("slaveDataSource") DataSource
slaveDataSource
) {
	logger.info("create routing datasource...");
	Map<Object, Object> map = new HashMap<>();
	map.put("masterDataSource", masterDataSource);
	map.put("slaveDataSource", slaveDataSource);
	RoutingDataSource routing = new RoutingDataSource();
	routing.setTargetDataSources(map);
	routing.setDefaultTargetDataSource(masterDataSource);
	return routing;
}
```

現在， RoutingDataSource 配置好了，但是，路由的選擇是寫死的，即永遠返回"masterDataSource"

- 現在問題來了：如何存儲動態選擇的key以及在哪設置key？

在Servlet的線程模型中，使用ThreadLocal存儲key最合適，因此，我們編寫一個RoutingDataSourceContext ，來設置並動態存儲key：
```java
public class RoutingDataSourceContext {
	// holds data source key in thread local:
	static final ThreadLocal<String> threadLocalDataSourceKey = new	ThreadLocal<>();
	public static String getDataSourceRoutingKey() {
		String key = threadLocalDataSourceKey.get();
		return key == null ? "masterDataSource" : key;
	}
	public RoutingDataSourceContext(String key) {
		threadLocalDataSourceKey.set(key);
	}
	public void close() {
		threadLocalDataSourceKey.remove();
	}
}
```

然後，修改 RoutingDataSource ，獲取key的代碼如下：
```java
public class RoutingDataSource extends AbstractRoutingDataSource {
	protected Object determineCurrentLookupKey() {
		return RoutingDataSourceContext.getDataSourceRoutingKey();
	}
}
```

這樣，在某個地方，例如一個Controller的方法內部，就可以動態設置DataSource的Key：
```java
@GetMapping("/findAllProductM")
public String findAllProductM() {
	String key = "masterDataSource";
	RoutingDataSourceContext routingDataSourceContext = new	RoutingDataSourceContext(key);
	productService.findAllProductM();
	return "master";
}
@GetMapping("/findAllProductS")
public String findAllProductS() {
	String key = "slaveDataSource";
	RoutingDataSourceContext routingDataSourceContext = new	RoutingDataSourceContext(key);
	productService.findAllProductS();
	return "slave";
}
```

到此為止，我們已經成功實現了數據庫的動態路由訪問。


##### 優化：
以上代碼是可行的，但是，需要讀數據庫的地方，就需要加上一大段RoutingDataSourceContextctx = ...代碼，使用起來十分不便。有沒有方法可以簡化呢？

有！

我們仔細想想，Spring提供的聲明式事務管理，就只需要一個 @Transactional() 註解，放在某個Java方法上，這個方法就自動具有了事務。

我們也可以編寫一個類似的 @RoutingWith("slaveDataSource") 註解，放到某個Controller的方法上，這個方法內部就自動選擇了對應的數據源。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RoutingWith {
	String value() default "master";
}
```

編譯前需要添加一個Maven依賴：
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

切面類：
```java
@Aspect
@Component
public class RoutingAspect {
	@Around("@annotation(routingWith)")
	public Object routingWithDataSource(ProceedingJoinPoint joinPoint, RoutingWith routingWith) throws Throwable {
		String key = routingWith.value();
		RoutingDataSourceContext ctx = new RoutingDataSourceContext(key);
		return joinPoint.proceed();
	}
}
```

注意方法的第二個參數RoutingWith是Spring傳入的註解實例，我們根據註解的value()獲取配置的key。

改造方法：
```java
@RoutingWith("masterDataSource")
@GetMapping("/findAllProductM")
public String findAllProductM() {
	/* String key = "masterDataSource";
	RoutingDataSourceContext routingDataSourceContext = new
	RoutingDataSourceContext(key);*/
	productService.findAllProductM();
	return "lagou";
}

@RoutingWith("slaveDataSource")
@GetMapping("/findAllProductS")
public String findAllProductS() {
	/*String key = "slaveDataSource";
	RoutingDataSourceContext routingDataSourceContext = new
	RoutingDataSourceContext(key);*/
	productService.findAllProductS();
	return "lagou";
}

```

到此為止，我們就實現了用註解動態選擇數據源的功能




