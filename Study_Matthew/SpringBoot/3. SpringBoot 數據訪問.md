---
date: 2021-11-05
tags: ["#SpringFramework/#SpringBoot"]
aliases: []
---

# Metadata

**Title** :: Java åŸºç¤ç­†è¨˜æ¨¡æ¿

**Author** :: #Matthew 

**Classification** :: #Learn #Java #Basic #SpringFramework/#SpringBoot 

**Status** :: #ğŸŒ±

**Type** :: #Note

**Previous** ::[[Study_Matthew/SpringBoot/2. SpringBoot æºç¢¼å‰–æ]]

**ParentNode** :: [[Study_Matthew/SpringBoot/SpringBoot]]

---

# 3.SpringBoot æ•¸æ“šè¨ªå•
## 3.1 æ•¸æ“šæºè‡ªå‹•é…ç½®æºç¢¼å‰–æ

### æ•¸æ“šæºé…ç½®æ–¹å¼

1. é¸æ“‡æ•¸æ“šåº«é©…å‹•çš„åº«æ–‡ä»¶
	
	åœ¨ maven ä¸­é…ç½®æ•¸æ“šåº«é©…å‹•
	```xml
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
	</dependency>
	```

2. é…ç½®æ•¸æ“šåº«é€£æ¥
	åœ¨application.propertiesä¸­é…ç½®æ•¸æ“šåº«é€£æ¥
	```txt
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
	spring.datasource.url=jdbc:mysql:///springboot_h?
	useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
	spring.datasource.username=root
	spring.datasource.password=root
	# spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
	```

3. é…ç½®spring-boot-starter-jdbc
	```xml
	<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
	</dependency>
	```

4. ç·¨å¯«æ¸¬è©¦é¡
	```java
	@RunWith(SpringRunner.class)
	@SpringBootTest(classes = SpringBootMytestApplication.class)
	class SpringBootMytestApplicationTests {

		@Autowired
		DataSource dataSource;

		@Test
		public void contextLoads() throws SQLException {
			Connection connection = dataSource.getConnection();
		}
	}
	```


### é€£æ¥æ± é…ç½®æ–¹å¼

1. é¸æ“‡æ•¸æ“šåº«é€£æ¥æ± çš„åº«æ–‡ä»¶

SpringBootæä¾›äº†ä¸‰ç¨®æ•¸æ“šåº«é€£æ¥æ± ï¼š
- HikariCP
- Commons DBCP2
- Tomcat JDBC Connection Pool

å…¶ä¸­spring boot2.xç‰ˆæœ¬é»˜èªä½¿ç”¨HikariCPï¼Œmavenä¸­é…ç½®å¦‚ä¸‹ï¼š
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

å¦‚æœä¸ä½¿ç”¨HikariCPï¼Œè€Œæ”¹ç”¨Commons DBCP2ï¼Œå‰‡é…ç½®å¦‚ä¸‹ï¼š
```xml
<dependency>
	<groupId>org.apache.commons</groupId>
	<artifactId>commons-dbcp2</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
	<exclusions>
		<exclusion>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
		</exclusion>
	</exclusions>
</dependency>
```

å¦‚æœä¸ä½¿ç”¨HikariCPï¼Œè€Œæ”¹ç”¨Tomcat JDBC Connection Poolï¼Œå‰‡é…ç½®å¦‚ä¸‹ï¼š
```xml
<dependency>
	<groupId>org.apache.tomcat</groupId>
	<artifactId>tomcat-jdbc</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jdbc</artifactId>
	<exclusions>
		<exclusion>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
		</exclusion>
	</exclusions>
</dependency>
```

æ€è€ƒï¼šç‚ºä»€éº¼èªªspringbooté»˜èªä½¿ç”¨çš„é€£æ¥æ± é¡å‹æ˜¯HikariCPï¼Œåœ¨é‚£æŒ‡å®šçš„ï¼Ÿ



### æ•¸æ“šæºè‡ªå‹•é…ç½®
spring.factoriesä¸­æ‰¾åˆ°æ•¸æ“šæºçš„é…ç½®é¡ï¼š

![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109141120.png]]

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class,DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {
	
	@Configuration(proxyBeanMethods = false)
	@Conditional(EmbeddedDatabaseCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import(EmbeddedDataSourceConfiguration.class)
	protected static class EmbeddedDatabaseConfiguration {
	}
	
	@Configuration(proxyBeanMethods = false)
	@Conditional(PooledDataSourceCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import({ DataSourceConfiguration.Hikari.class,DataSourceConfiguration.Tomcat.class,DataSourceConfiguration.Dbcp2.class,DataSourceConfiguration.Generic.class,DataSourceJmxConfiguration.class })
	protected static class PooledDataSourceConfiguration {
	}
...

```

@Conditional(PooledDataSourceCondition.class) æ ¹æ“šåˆ¤æ–·æ¢ä»¶ï¼Œå¯¦ä¾‹åŒ–é€™å€‹é¡ï¼ŒæŒ‡å®šäº†é…ç½®æ–‡ä»¶ä¸­ï¼Œå¿…é ˆæœ‰typeé€™å€‹å±¬æ€§
![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109141332.png]]

å¦å¤–springboot é»˜èªæ”¯æŒ type é¡å‹è¨­ç½®çš„æ•¸æ“šæºï¼›
```java
@Import({ DataSourceConfiguration.Hikari.class,
	DataSourceConfiguration.Tomcat.class,
	DataSourceConfiguration.Dbcp2.class,
	DataSourceConfiguration.Generic.class,
	DataSourceJmxConfiguration.class })
```

```java
abstract class DataSourceConfiguration {
	DataSourceConfiguration() {
	}
	protected static <T> T createDataSource(DataSourceProperties properties,
	Class<? extends DataSource> type) {
		return properties.initializeDataSourceBuilder().type(type).build();
	}
	//è‡ªå®šä¹‰è¿æ¥æ±  æ¥å£ spring.datasource.type é…ç½®
	@ConditionalOnMissingBean({DataSource.class})
	@ConditionalOnProperty(
		name = {"spring.datasource.type"}
	)
	static class Generic {
		Generic() {
		}
		@Bean
		public DataSource dataSource(DataSourceProperties properties) {
			//åˆ›å»ºæ•°æ®æº initializeDataSourceBuilder DataSourceBuilder
			return properties.initializeDataSourceBuilder().build();
		}
	}
	//Dbcp2 è¿æ¥æ± 
	@ConditionalOnClass({BasicDataSource.class})
	@ConditionalOnMissingBean({DataSource.class})
	@ConditionalOnProperty(
		name = {"spring.datasource.type"},
		havingValue = "org.apache.commons.dbcp2.BasicDataSource",
		matchIfMissing = true
	)
	static class Dbcp2 {
		Dbcp2() {
		}
		
		@Bean
		@ConfigurationProperties(
			prefix = "spring.datasource.dbcp2"
		)
		public BasicDataSource dataSource(DataSourceProperties properties) {
		
			return (BasicDataSource)DataSourceConfiguration.createDataSource(properties, BasicDataSource.class);
		}
	}
	
	//2.0 ä¹‹åé»˜è®¤é»˜è®¤ä½¿ç”¨ hikari è¿æ¥æ± 
	@ConditionalOnClass({HikariDataSource.class})
	@ConditionalOnMissingBean({DataSource.class})
	@ConditionalOnProperty(
		name = {"spring.datasource.type"},
		havingValue = "com.zaxxer.hikari.HikariDataSource",
		matchIfMissing = true
	)
	static class Hikari {
		Hikari() {
		}
		@Bean
		@ConfigurationProperties(
			prefix = "spring.datasource.hikari"
		)
		public HikariDataSource dataSource(DataSourceProperties properties){
			HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);
			if (StringUtils.hasText(properties.getName())) {
				dataSource.setPoolName(properties.getName());
			}
			return dataSource;
		}
	}
	
	//2.0 ä¹‹åé»˜è®¤ä¸æ˜¯ä½¿ç”¨ tomcat è¿æ¥æ± ,æˆ–è€…ä½¿ç”¨tomcat å®¹å™¨
	//å¦‚æœå¯¼å…¥tomcat jdbcè¿æ¥æ±  åˆ™ä½¿ç”¨æ­¤è¿æ¥æ± ï¼Œåœ¨ä½¿ç”¨tomcatå®¹å™¨æ—¶å€™ æˆ–è€…å¯¼å…¥æ­¤åŒ…æ—¶å€™
	@ConditionalOnClass({org.apache.tomcat.jdbc.pool.DataSource.class})
	@ConditionalOnMissingBean({DataSource.class})
	//å¹¶ä¸”é…ç½®çš„é…ç½®æ˜¯ org.apache.tomcat.jdbc.pool.DataSource ä¼šé‡‡ç”¨tomcat è¿æ¥æ± 
	@ConditionalOnProperty(
		name = {"spring.datasource.type"}, //nameç”¨æ¥ä»application.propertiesä¸­è¯»å–æŸä¸ªå±æ€§å€¼
		havingValue = "org.apache.tomcat.jdbc.pool.DataSource",
		//ç¼ºå°‘è¯¥propertyæ—¶æ˜¯å¦å¯ä»¥åŠ è½½ã€‚å¦‚æœä¸ºtrueï¼Œæ²¡æœ‰è¯¥propertyä¹Ÿä¼šæ­£å¸¸åŠ è½½ï¼›åä¹‹	æŠ¥é”™
		//ä¸ç®¡ä½ é…ä¸é…ç½® éƒ½ä»¥ tomcat è¿æ¥æ± ä½œä¸ºè¿æ¥æ± 
		matchIfMissing = true //é»˜è®¤æ˜¯false
	)
	
	static class Tomcat {
		Tomcat() {
		}
		//ç»™å®¹å™¨ä¸­åŠ æ•°æ®æº
		@Bean
		@ConfigurationProperties(
			prefix = "spring.datasource.tomcat"
		)
		public org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties) {
		org.apache.tomcat.jdbc.pool.DataSource dataSource =	
			(org.apache.tomcat.jdbc.pool.DataSource)DataSourceConfiguration.createDataSource(properties, org.apache.tomcat.jdbc.pool.DataSource.class);
		DatabaseDriver databaseDriver =	
			DatabaseDriver.fromJdbcUrl(properties.determineUrl());
			
		String validationQuery = databaseDriver.getValidationQuery();
			
		if (validationQuery != null) {
			dataSource.setTestOnBorrow(true);
			dataSource.setValidationQuery(validationQuery);
		}
		return dataSource;
		}
	}
}
```

å¦‚æœåœ¨é¡è·¯å¾‘æ²’æœ‰æ‰¾åˆ° jaråŒ… å‰‡æœƒè·‘å‡ºç•°å¸¸

Field dataSource in com.example.springsession.demo.jpa.StudentController required a bean of type â€˜javax.sql.DataSourceâ€™ that could not be found.
-Bean method â€˜dataSourceâ€™ not loaded because @ConditionalOnClass did not find required
class â€˜org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseTypeâ€™

- Bean method â€˜dataSourceâ€™ not loaded because @ConditionalOnClass did not findrequired classes â€˜javax.transaction.TransactionManagerâ€™, â€˜org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseTypeâ€™

DataSourceConfiguration

é…ç½®æ–‡ä»¶ä¸­æ²’æœ‰æŒ‡å®šæ•¸æ“šæºæ™‚å€™ æœƒæ ¹æ“šè¨»è§£åˆ¤æ–·ç„¶å¾Œé¸æ“‡ç›¸æ‡‰çš„å¯¦ä¾‹åŒ–æ•¸æ“šæºå°è±¡ï¼å‰‡ type ç‚ºç©ºã€‚
```java
@ConditionalOnClass({HikariDataSource.class})
@ConditionalOnMissingBean({DataSource.class}) //æ³¨è§£åˆ¤æ–­æ˜¯å¦æ‰§è¡Œåˆå§‹åŒ–ä»£ç ï¼Œå³å¦‚
æœç”¨æˆ·å·²ç»åˆ›å»ºäº†beanï¼Œåˆ™ç›¸å…³çš„åˆå§‹åŒ–ä»£ç ä¸å†æ‰§è¡Œ
@ConditionalOnProperty(
	name = {"spring.datasource.type"}, //æ‹¿é…ç½®æ–‡ä»¶ä¸­çš„type å¦‚æœä¸ºç©ºè¿”å›fale
	havingValue = "com.zaxxer.hikari.HikariDataSource", //type ä¸ä¸ºç©ºåˆ™å»
	havingValue å¯¹æ¯” ï¼Œç›¸åŒåˆ™ture å¦åˆ™ä¸ºfalse
	matchIfMissing = true // ä¸ç®¡ä¸Šé¢æ–‡ä»¶ä¸­æ˜¯å¦é…ç½®ï¼Œé»˜è®¤éƒ½è¿›è¡ŒåŠ è½½ï¼ŒmatchIfMissingçš„é»˜å€¼ä¸ºfalse
)
static class Hikari {
	Hikari() {
	}
	@Bean
	@ConfigurationProperties(
		prefix = "spring.datasource.hikari"
	)
	public HikariDataSource dataSource(DataSourceProperties properties) {
	//åˆ›å»ºæ•°æ®æº
	HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);
		if (StringUtils.hasText(properties.getName())) {
			dataSource.setPoolName(properties.getName());
		}
		return dataSource;
	}
```

createDataSource æ–¹æ³•
```java
protected static <T> T createDataSource(DataSourceProperties properties, Class<? extends DataSource> type) {
	// ä½¿ç”¨DataSourceBuilder å»ºé€ æ•°æ®æºï¼Œåˆ©ç”¨åå°„åˆ›å»ºtypeæ•°æ®æºï¼Œç„¶åç»‘å®šç›¸å…³å±æ€§
	return properties.initializeDataSourceBuilder().type(type).build();
}
```

DataSourceBuilder é¡

è¨­ç½®type
```java
public <D extends DataSource> DataSourceBuilder<D> type(Class<D> type) {
	this.type = type;
	return this;
}
```

æ ¹æ“šè¨­ç½®typeçš„é¸æ“‡é¡å‹
```java
private Class<? extends DataSource> getType() {
	//å¦‚æœæ²¡æœ‰é…ç½®type åˆ™ä¸ºç©º é»˜è®¤é€‰æ‹© findType
	Class<? extends DataSource> type = this.type != null ? this.type :
	findType(this.classLoader);
	if (type != null) {
		return type;
	} else {
		throw new IllegalStateException("No supported DataSource type found");
	}
}
```

```java
public static Class<? extends DataSource> findType(ClassLoader classLoader){
	String[] var1 = DATA_SOURCE_TYPE_NAMES;
	int var2 = var1.length;
	int var3 = 0;
	while(var3 < var2) {
		String name = var1[var3];
		try {
			return ClassUtils.forName(name, classLoader);
		} catch (Exception var6) {
			++var3;
		}
	}
	return null;
}
```

//æ•¸çµ„
```java
private static final String[] DATA_SOURCE_TYPE_NAMES = new String[]
{"com.zaxxer.hikari.HikariDataSource",
"org.apache.tomcat.jdbc.pool.DataSource",
"org.apache.commons.dbcp2.BasicDataSource"};
```

å–å‡ºä¾†çš„ç¬¬ä¸€å€‹å€¼å°±æ˜¯com.zaxxer.hikari.HikariDataSourceï¼Œé‚£éº¼è­‰å¯¦åœ¨æ²’æœ‰æŒ‡å®šTypeçš„æƒ…æ³ä¸‹ï¼Œé»˜èªé¡å‹ç‚ºcom.zaxxer.hikari.HikariDataSource



## 3.2 Druidé€£æ¥æ± çš„é…ç½®

### æ•´åˆæ•ˆæœå¯¦ç¾
1. åœ¨pom.xmlä¸­å¼•å…¥druidæ•¸æ“šæº
	```xml
	<dependency>
		<groupId>com.alibaba</groupId>
		<artifactId>druid-spring-boot-starter</artifactId>
		<version>1.1.10</version>
	</dependency>
	```

2. åœ¨application.ymlä¸­å¼•å…¥druidçš„ç›¸é—œé…ç½®
	```yml
	spring:
		datasource:
			username: root
			password: root
			url: jdbc:mysql:///springboot_h?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=UTC
			driver-class-name: com.mysql.cj.jdbc.Driver
			initialization-mode: always
			# ä½¿ç”¨druidæ•°æ®æº
			type: com.alibaba.druid.pool.DruidDataSource
			# æ•°æ®æºå…¶ä»–é…ç½®
			initialSize: 5
			minIdle: 5
			maxActive: 20
			maxWait: 60000
			timeBetweenEvictionRunsMillis: 60000
			minEvictableIdleTimeMillis: 300000
			validationQuery: SELECT 1 FROM DUAL
			testWhileIdle: true
			testOnBorrow: false
			testOnReturn: false
			poolPreparedStatements: true
			# é…ç½®ç›‘æ§ç»Ÿè®¡æ‹¦æˆªçš„filtersï¼Œå»æ‰åç›‘æ§ç•Œé¢sqlæ— æ³•ç»Ÿè®¡ï¼Œ'wall'ç”¨äºé˜²ç«å¢™
			filters: stat,wall,log4j
			maxPoolPreparedStatementPerConnectionSize: 20
			useGlobalDataSourceStat: true
			connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
	```

	é€²è¡Œæ¸¬è©¦ï¼š
	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109143455.png]]

	ä½†æ˜¯DubugæŸ¥çœ‹DataSourceçš„å€¼ï¼Œæœƒç™¼ç¾æœ‰äº›å±¬æ€§æ˜¯æ²’æœ‰ç”Ÿæ•ˆçš„
	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109143515.png]]

	é€™æ˜¯å› ç‚ºï¼šå¦‚æœå–®ç´”åœ¨ymlæ–‡ä»¶ä¸­ç·¨å¯«å¦‚ä¸Šçš„é…ç½®ï¼ŒSpringBootè‚¯å®šæ˜¯è®€å–ä¸åˆ°druidçš„ç›¸é—œé…ç½®çš„ã€‚å› ç‚ºå®ƒä¸¦ä¸åƒæˆ‘å€‘åŸç”Ÿçš„jdbcï¼Œç³»çµ±é»˜èªå°±ä½¿ç”¨DataSourcePropertiesèˆ‡å…¶å±¬æ€§é€²è¡Œäº†ç¶å®šã€‚æ‰€ä»¥æˆ‘å€‘æ‡‰è©²ç·¨å¯«ä¸€å€‹é¡èˆ‡å…¶å±¬æ€§é€²è¡Œç¶å®š

3. ç·¨å¯«æ•´åˆdruidçš„é…ç½®é¡DruidConfig
	```java
	public class DruidConfig {
		@ConfigurationProperties(prefix = "spring.datasource")
		@Bean
		public DataSource druid(){
			return new DruidDataSource();
		}
	}
	```

	æ¸¬è©¦çš„æ™‚å€™ï¼Œçªç„¶ç™¼ç¾æ§åˆ¶å°å ±éŒ¯äº†ã€‚ç¶“éæŸ¥æ‰¾ç™¼ç¾æ˜¯ymlæ–‡ä»¶è£¡çš„
	```log
	filters: stat,wall,log4j
	```

	å› ç‚ºæˆ‘å€‘springBoot2.0ä»¥å¾Œä½¿ç”¨çš„æ—¥èªŒæ¡†æ¶å·²ç¶“ä¸å†ä½¿ç”¨log4jäº†ã€‚æ­¤æ™‚æ‡‰è©²å¼•å…¥ç›¸æ‡‰çš„é©é…å™¨ã€‚
	æˆ‘å€‘å¯ä»¥åœ¨pom.xmlæ–‡ä»¶ä¸ŠåŠ å…¥
	```xml
	<!--å¼•å…¥é©é…å™¨-->
	<dependency>
		<groupId>org.slf4j</groupId>
		<artifactId>slf4j-log4j12</artifactId>
	</dependency>
	```
	é€™æ™‚é€²è¡Œç›¸é—œæ¸¬è©¦å°±å¯ä»¥äº†


## 3.3 SpringBootæ•´åˆMybatis
 MyBatis æ˜¯ä¸€æ¬¾å„ªç§€çš„æŒä¹…å±¤æ¡†æ¶ï¼ŒSpring Bootå®˜æ–¹é›–ç„¶æ²’æœ‰å°MyBatisé€²è¡Œæ•´åˆï¼Œä½†æ˜¯MyBatisåœ˜éšŠè‡ªè¡Œé©é…äº†å°æ‡‰çš„å•Ÿå‹•å™¨ï¼Œé€²ä¸€æ­¥ç°¡åŒ–äº†ä½¿ç”¨MyBatisé€²è¡Œæ•¸æ“šçš„æ“ä½œ 
 
 å› ç‚ºSpring Bootæ¡†æ¶é–‹ç™¼çš„ä¾¿åˆ©æ€§ï¼Œæ‰€ä»¥å¯¦ç¾Spring Bootèˆ‡æ•¸æ“šè¨ªå•å±¤æ¡†æ¶ï¼ˆä¾‹å¦‚MyBatisï¼‰çš„æ•´åˆéå¸¸ç°¡å–®ï¼Œä¸»è¦æ˜¯å¼•å…¥å°æ‡‰çš„ä¾è³´å•Ÿå‹•å™¨ï¼Œä¸¦é€²è¡Œæ•¸æ“šåº«ç›¸é—œåƒæ•¸è¨­ç½®å³å¯

### æ•´åˆæ•ˆæœå¯¦ç¾
1. æ–°å»ºspringbooté …ç›®ï¼Œä¸¦å°å…¥mybatisçš„pomé…ç½®
	```xml
	<!-- é…ç½®æ•°æ®åº“é©±åŠ¨å’Œmybatis dependency -->
	<dependency>
		<groupId>org.mybatis.spring.boot</groupId>
		<artifactId>mybatis-spring-boot-starter</artifactId>
		<version>1.3.2</version>
	</dependency>

	<dependency>
		<groupId>org.projectlombok</groupId>
		<artifactId>lombok</artifactId>
		<optional>true</optional>
	</dependency>
	```

	```yml
	application.ymlé…ç½®

	spring:
		datasource:
		username: root
		password: root
		url: jdbc:mysql:///springboot_h?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=UTC
		driver-class-name: com.mysql.jdbc.Driver
		# ä½¿ç”¨druidæ•°æ®æº
		type: com.alibaba.druid.pool.DruidDataSource
	```

2. åŸºç¤é¡ï¼ˆä½¿ç”¨lombokè‡ªå‹•ç”Ÿæˆget/setæ–¹æ³•ï¼‰
	```java
	package com.lagou.demo.domain;

	import lombok.Data;

	@Data
	public class User {
		private Integer id;
		private String username;
		private Integer age;
	}
	```

3. æ¸¬è©¦daoï¼ˆmybatisä½¿ç”¨è¨»è§£é–‹ç™¼ï¼‰
	```java
	package com.lagou.dao;

	import com.lagou.pojo.User;
	import org.apache.ibatis.annotations.Mapper;
	import org.apache.ibatis.annotations.Select;

	@Mapper
	public interface UserDao {
		@Select("SELECT * FROM USER")
		List<User> getUser();
	}
	```

4. æ¸¬è©¦service
	```java
	package com.example.demo.service;

	import com.example.demo.dao.UserDao;
	import com.example.demo.domain.User;
	import lombok.extern.slf4j.Slf4j;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Service;
	import java.util.List;

	@Service
	public class UserService {
		Logger logger = LoggerFactory.getLogger(UserService.class);

		@Autowired
		private UserDao userDao;

		public List<User> getUser(){
			List<User> userList = userDao.getUser();
			logger.info("æŸ¥è¯¢å‡ºæ¥çš„ç”¨æˆ·ä¿¡æ¯ï¼Œ{}",userList.toString());
			return userList;
		}
	}
	```

5. serviceå°æ‡‰çš„testé¡ï¼ˆè©²æ¸¬è©¦é¡ç¹¼æ‰¿ä¸»æ¸¬è©¦é¡ï¼ˆä¸»æ¸¬è©¦é¡ç›´æ¥åœ¨å•Ÿå‹•æ–‡ä»¶ä¸Šgoto testå³å¯è‡ªå‹•ç”Ÿæˆï¼‰ï¼‰
	```java
	package com.example.demo.service;

	import com.example.demo.DemoApplicationTests;
	import org.junit.Test;
	import org.junit.runner.RunWith;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.context.SpringBootTest;
	import static org.junit.Assert.*;

	public class UserServiceTest extends DemoApplicationTests {
		@Autowired
		private UserService userService;
		@Test
		public void getUser() {
			userService.getUser();
		}
	}
	```

	```java
	package com.example.demo;
	import org.junit.Test;
	import org.junit.runner.RunWith;
	import org.springframework.boot.test.context.SpringBootTest;
	import org.springframework.test.context.junit4.SpringRunner;

	@RunWith(SpringRunner.class)
	@SpringBootTest
	public class DemoApplicationTests {
		@Test
		public void contextLoads() {
		}
	}
	```

6. é‹è¡Œæ¸¬è©¦é¡è¼¸å‡ºçµæœ
	
	æŸ¥è©¢å‡ºä¾†çš„ç”¨æˆ¶ä¿¡æ¯ï¼Œ[User(id=1, username=test, age=11)]



## 3.4 Mybatisè‡ªå‹•é…ç½®æºç¢¼åˆ†æ

1. springbooté …ç›®æœ€æ ¸å¿ƒçš„å°±æ˜¯è‡ªå‹•åŠ è¼‰é…ç½®ï¼Œè©²åŠŸèƒ½å‰‡ä¾è³´çš„æ˜¯ä¸€å€‹è¨»è§£@SpringBootApplicationä¸­çš„@EnableAutoConfiguration
	
2. EnableAutoConfigurationä¸»è¦æ˜¯é€šéAutoConfigurationImportSelectoré¡ä¾†åŠ è¼‰
	
	ä»¥mybatisç‚ºä¾‹ï¼Œ*selectoré€šéåå°„åŠ è¼‰spring.factoriesä¸­æŒ‡å®šçš„javaé¡ï¼Œä¹Ÿå°±æ˜¯åŠ è¼‰MybatisAutoConfigurationé¡ï¼ˆè©²é¡æœ‰Configurationè¨»è§£ï¼Œå±¬æ–¼é…ç½®é¡ï¼‰

	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109145353.png]]
	
	![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109145403.png]]
	
	```java
	/**
	* {@link EnableAutoConfiguration Auto-Configuration} for Mybatis.
	Contributes a é‡ç‚¹ï¼šSqlSessionFactory å’Œ SqlSessionTemplate ä¸¤ä¸ªç±»
	* {@link SqlSessionFactory} and a {@link SqlSessionTemplate}.
	*
	* If {@link org.mybatis.spring.annotation.MapperScan} is used, or a
	* configuration file is specified as a property, those will be considered,
	* otherwise this auto-configuration will attempt to register mappers based
	on
	* the interface definitions in or under the root auto-configuration
	package.
	*
	* @author EddÃº MelÃ©ndez
	* @author Josh Long
	* @author Kazuki Shimizu
	* @author Eduardo MacarrÃ³n
	*/
	@org.springframework.context.annotation.Configuration
	@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})
	@ConditionalOnBean(DataSource.class)
	@EnableConfigurationProperties(MybatisProperties.class)
	@AutoConfigureAfter(DataSourceAutoConfiguration.class)
	public class MybatisAutoConfiguration {
		private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);
		// //ä¸mybatisé…ç½®æ–‡ä»¶å¯¹åº”
		private final MybatisProperties properties;
		private final Interceptor[] interceptors;
		private final ResourceLoader resourceLoader;
		private final DatabaseIdProvider databaseIdProvider;
		private final List<ConfigurationCustomizer> configurationCustomizers;
		public MybatisAutoConfiguration(MybatisProperties properties,
		ObjectProvider<Interceptor[]>
		interceptorsProvider,
		ResourceLoader resourceLoader,
		ObjectProvider<DatabaseIdProvider>
		databaseIdProvider,
		ObjectProvider<List<ConfigurationCustomizer>>
		configurationCustomizersProvider) {
		this.properties = properties;
		this.interceptors = interceptorsProvider.getIfAvailable();
		this.resourceLoader = resourceLoader;
		this.databaseIdProvider = databaseIdProvider.getIfAvailable();
		this.configurationCustomizers =
		configurationCustomizersProvider.getIfAvailable();
	}
		
	//postConstructä½œç”¨æ˜¯åœ¨åˆ›å»ºç±»çš„æ—¶å€™å…ˆè°ƒç”¨ï¼Œ æ ¡éªŒé…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
	@PostConstruct
	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation() &&
		StringUtils.hasText(this.properties.getConfigLocation())) {
		Resource resource =	this.resourceLoader.getResource(this.properties.getConfigLocation());
		Assert.state(resource.exists(), "Cannot find config location: " + resource + " (please add config file or check your Mybatis			configuration)");
		}
	}
		
	//conditionalOnMissingBeanä½œç”¨ï¼šåœ¨æ²¡æœ‰ç±»çš„æ—¶å€™è°ƒç”¨ï¼Œåˆ›å»ºsqlsessionFactory sqlsessionfactoryæœ€ä¸»è¦çš„æ˜¯åˆ›å»ºå¹¶ä¿å­˜äº†Configurationç±»
	@Bean
	@ConditionalOnMissingBean
	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfigLocation())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
		}
		Configuration configuration = this.properties.getConfiguration();
		if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
			configuration = new Configuration();
		}
		if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
			for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
				customizer.customize(configuration);
			}
		}
		factory.setConfiguration(configuration);
		if (this.properties.getConfigurationProperties() != null) {
			factory.setConfigurationProperties(this.properties.getConfigurationProperties());
		}
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}
		// //è·å–SqlSessionFactoryBeançš„getObject()ä¸­çš„å¯¹è±¡æ³¨å…¥Springå®¹å™¨ï¼Œä¹Ÿå°±æ˜¯ SqlSessionFactoryå¯¹è±¡
		return factory.getObject();
	}
		
	@Bean
	@ConditionalOnMissingBean
	// å¾€Springå®¹å™¨ä¸­æ³¨å…¥SqlSessionTemplateå¯¹è±¡
	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);
		} else {
			return new SqlSessionTemplate(sqlSessionFactory);
		}
	}
	```

3. MybatisAutoConfigurationï¼š
	
	â‘ é¡ä¸­æœ‰å€‹MybatisPropertiesé¡ï¼Œè©²é¡å°æ‡‰çš„æ˜¯mybatisçš„é…ç½®æ–‡ä»¶

	â‘¡é¡ä¸­æœ‰å€‹sqlSessionFactoryæ–¹æ³•ï¼Œä½œç”¨æ˜¯å‰µå»ºSqlSessionFactoryé¡ã€Configurationé¡ï¼ˆmybatisæœ€ä¸»è¦çš„é¡ï¼Œä¿å­˜è‘—èˆ‡mybatisç›¸é—œçš„æ±è¥¿ï¼‰

	â‘¢SelSessionTemplateï¼Œä½œç”¨æ˜¯èˆ‡mapperProoxyä»£ç†é¡æœ‰é—œ

	sqlSessionFactoryä¸»è¦æ˜¯é€šéå‰µå»ºäº†ä¸€å€‹SqlSessionFactoryBeanï¼Œé€™å€‹é¡å¯¦ç¾äº†FactoryBeanæ¥å£ï¼Œæ‰€ä»¥åœ¨Springå®¹å™¨å°±æœƒæ³¨å…¥é€™å€‹é¡ä¸­å®šç¾©çš„getObjectæ–¹æ³•è¿”å›çš„å°è±¡ã€‚

	çœ‹ä¸€ä¸‹getObject()æ–¹æ³•åšäº†ä»€éº¼ï¼Ÿ

	```java
	@Override
	public SqlSessionFactory getObject() throws Exception {
		if (this.sqlSessionFactory == null) {
		afterPropertiesSet();
		}
		return this.sqlSessionFactory;
		}
		@Override
		public void afterPropertiesSet() throws Exception {
			
		notNull(dataSource, "Property 'dataSource' is required");
		notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required");
			
		state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),
		"Property 'configuration' and 'configLocation' can not specified with together");
			
		this.sqlSessionFactory = buildSqlSessionFactory();
	}
	```

	```java
	protected SqlSessionFactory buildSqlSessionFactory() throws Exception {
		final Configuration targetConfiguration;
		XMLConfigBuilder xmlConfigBuilder = null;
		if (this.configuration != null) {
			targetConfiguration = this.configuration;
			if (targetConfiguration.getVariables() == null) {
				targetConfiguration.setVariables(this.configurationProperties);
			} else if (this.configurationProperties != null) {
				targetConfiguration.getVariables().putAll(this.configurationProperties);
			}
		} else if (this.configLocation != null) {
			xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);
			targetConfiguration = xmlConfigBuilder.getConfiguration();
		} else {
			LOGGER.debug(
			() -> "Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration");
			targetConfiguration = new Configuration();
			Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);
		}
		Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);
		Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);
		Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);
		
		if (hasLength(this.typeAliasesPackage)) {
			scanClasses( this.typeAliasesPackage, this.typeAliasesSuperType)
							.stream()
							.filter(clazz -> !clazz.isAnonymousClass())
							.filter(clazz -> !clazz.isInterface())
							.filter(clazz -> !clazz.isMemberClass())
							.forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);
		}
		
		if (!isEmpty(this.typeAliases)) {
			Stream.of(this.typeAliases).forEach(typeAlias -> {
				targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);
				LOGGER.debug(() -> "Registered type alias: '" + typeAlias + "'");
			});
		}
		
		if (!isEmpty(this.plugins)) {
			Stream.of(this.plugins).forEach(plugin -> {
				targetConfiguration.addInterceptor(plugin);
				LOGGER.debug(() -> "Registered plugin: '" + plugin + "'");
			});
		}
		
		if (hasLength(this.typeHandlersPackage)) {
			scanClasses(this.typeHandlersPackage, TypeHandler.class)
				.stream()
				.filter(clazz -> !clazz.isAnonymousClass())
				.filter(clazz -> !clazz.isInterface())
				.filter(clazz -> !Modifier.isAbstract(clazz.getModifiers()))
				.forEach(targetConfiguration.getTypeHandlerRegistry()::register);
		}
		
		if (!isEmpty(this.typeHandlers)) {
			Stream.of(this.typeHandlers).forEach(typeHandler -> {
				targetConfiguration.getTypeHandlerRegistry().register(typeHandler);
				LOGGER.debug(() -> "Registered type handler: '" + typeHandler +	"'");
			});
		}
		
		targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);
		
		if (!isEmpty(this.scriptingLanguageDrivers)) {
			Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -> {
				targetConfiguration.getLanguageRegistry().register(languageDriver);
				LOGGER.debug(() -> "Registered scripting language driver: '" + languageDriver + "'");
			});
		}
		
		Optional.ofNullable(this.defaultScriptingLanguageDriver).ifPresent(targetConfiguration::setDefaultScriptingLanguage);
		
		if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls
			try {
			targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(thi
			s.dataSource));
			} catch (SQLException e) {
			throw new NestedIOException("Failed getting a databaseId", e);
			}
		}
		
		Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);
		
		if (xmlConfigBuilder != null) {
			try {
				xmlConfigBuilder.parse();
				LOGGER.debug(() -> "Parsed configuration file: '" +
				this.configLocation + "'");
			} catch (Exception ex) {
				throw new NestedIOException("Failed to parse config resource: " +
				this.configLocation, ex);
			} finally {
				ErrorContext.instance().reset();
			}
		}
		
		targetConfiguration.setEnvironment(
			
			new Environment(
				this.environment,this.transactionFactory == null ? 
				new SpringManagedTransactionFactory() : 
				this.transactionFactory,
				this.dataSource));
		
			if (this.mapperLocations != null) {
				if (this.mapperLocations.length == 0) {
					LOGGER.warn(() -> "Property 'mapperLocations' was specified but matching resources are not found.");
				} else {
					for (Resource mapperLocation : this.mapperLocations) {
						if (mapperLocation == null) {
							continue;
						}
						try {
							XMLMapperBuilder xmlMapperBuilder = new
							XMLMapperBuilder(mapperLocation.getInputStream(),
							targetConfiguration, mapperLocation.toString(),
							targetConfiguration.getSqlFragments());
							//è¿™ä¸ªæ–¹æ³•å·²ç»æ˜¯mybaitsçš„æºç ï¼Œåˆå§‹åŒ–æµç¨‹
							xmlMapperBuilder.parse();
						} catch (Exception e) {
							throw new NestedIOException("Failed to parse mapping resource: '" + mapperLocation + "'", e);
						} finally {
							ErrorContext.instance().reset();
						}
						LOGGER.debug(() -> "Parsed mapper file: '" + mapperLocation + "'");
					}
				}
			} else {
				LOGGER.debug(() -> "Property 'mapperLocations' was not specified.");
			}
			//è¿™ä¸ªæ–¹æ³•å·²ç»æ˜¯mybaitsçš„æºç ï¼Œåˆå§‹åŒ–æµç¨‹
			return this.sqlSessionFactoryBuilder.build(targetConfiguration);
		}
	```

	é€™å€‹å·²ç¶“å¾ˆæ˜é¡¯äº†ï¼Œå¯¦éš›ä¸Šå°±æ˜¯èª¿ç”¨äº†MyBatisçš„åˆå§‹åŒ–æµç¨‹

	ç¾åœ¨å·²ç¶“å¾—åˆ°äº†SqlSessionFactoryäº†ï¼Œæ¥ä¸‹ä¾†å°±æ˜¯å¦‚ä½•æƒæåˆ°ç›¸é—œçš„Mapperæ¥å£äº†ã€‚
	
	é€™å€‹éœ€è¦çœ‹é€™å€‹è¨»è§£
	
	@MapperScan(basePackages = â€œcom.mybatis.mapperâ€)

	```java
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.TYPE)
	@Documented
	@Import(MapperScannerRegistrar.class)
	@Repeatable(MapperScans.class)
	public @interface MapperScan
	```

	é€šé@Importçš„æ–¹å¼æœƒæƒæåˆ°MapperScannerRegistraré¡ã€‚
	
	MapperScannerRegistrarå¯¦ç¾äº†ImportBeanDefinitionRegistraræ¥å£ï¼Œé‚£éº¼åœ¨springå¯¦ä¾‹åŒ–ä¹‹å‰å°±æœƒèª¿ç”¨åˆ°registerBeanDefinitionsæ–¹æ³•

	```java
	public class MapperScannerRegistrar implements
	ImportBeanDefinitionRegistrar, ResourceLoaderAware
	```

	```java
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		//æ‹¿åˆ°MapperScanæ³¨è§£ï¼Œå¹¶è§£ææ³¨è§£ä¸­å®šä¹‰çš„å±æ€§å°è£…æˆAnnotationAttributeså¯¹è±¡
		AnnotationAttributes mapperScanAttrs = AnnotationAttributes
		.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
		
		if (mapperScanAttrs != null) {
			registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,
			generateBaseBeanName(importingClassMetadata, 0));
		}
	}

	void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) {
		
		BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
		builder.addPropertyValue("processPropertyPlaceHolders", true);
		
		Class<? extends Annotation> annotationClass = annoAttrs.getClass("annotationClass");
		if (!Annotation.class.equals(annotationClass)) {
			builder.addPropertyValue("annotationClass", annotationClass);
		}
		
		Class<?> markerInterface = annoAttrs.getClass("markerInterface");
		if (!Class.class.equals(markerInterface)) {
			builder.addPropertyValue("markerInterface", markerInterface);
		}
		
		Class<? extends BeanNameGenerator> generatorClass = annoAttrs.getClass("nameGenerator");
		if (!BeanNameGenerator.class.equals(generatorClass)) {
			builder.addPropertyValue("nameGenerator", BeanUtils.instantiateClass(generatorClass));
		}
		
		Class<? extends MapperFactoryBean> mapperFactoryBeanClass = annoAttrs.getClass("factoryBean");
		if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {
			builder.addPropertyValue("mapperFactoryBeanClass", mapperFactoryBeanClass);
		}
		
		String sqlSessionTemplateRef = annoAttrs.getString("sqlSessionTemplateRef");
		if (StringUtils.hasText(sqlSessionTemplateRef)) {
			builder.addPropertyValue("sqlSessionTemplateBeanName", annoAttrs.getString("sqlSessionTemplateRef"));
		}
		
		String sqlSessionFactoryRef = annoAttrs.getString("sqlSessionFactoryRef");
			if (StringUtils.hasText(sqlSessionFactoryRef)) {
			builder.addPropertyValue("sqlSessionFactoryBeanName", annoAttrs.getString("sqlSessionFactoryRef"));
		}
		
		List<String> basePackages = new ArrayList<>();
		
		basePackages.addAll(
		Arrays.stream(annoAttrs.getStringArray("value")).filter(StringUtils::hasText).collect(Collectors.toList()));
		
		basePackages.addAll(Arrays.stream(annoAttrs.getStringArray("basePackages"))
			.filter(StringUtils::hasText)
			.collect(Collectors.toList()));
		
		basePackages.addAll(Arrays.stream(annoAttrs.getClassArray("basePackageClasses"))
			.map(ClassUtils::getPackageName)
			.collect(Collectors.toList()));
		
		if (basePackages.isEmpty()) {
			basePackages.add(getDefaultBasePackage(annoMeta));
		}
		
		String lazyInitialization = annoAttrs.getString("lazyInitialization");
		if (StringUtils.hasText(lazyInitialization)) {
			builder.addPropertyValue("lazyInitialization", lazyInitialization);
		}
		
		builder.addPropertyValue("basePackage", StringUtils.collectionToCommaDelimitedString(basePackages));
		//æŠŠç±»å‹ä¸ºMapperScannerConfigurerçš„æ³¨å†Œåˆ°springå®¹å™¨ä¸­
		registry.registerBeanDefinition(beanName, builder.getBeanDefinition());
	}
	```

	MapperScannerConfigurerå¯¦ç¾äº†BeanDefinitionRegistryPostProcessoræ¥å£ï¼Œæ‰€ä»¥æ¥è‘—åˆæœƒæƒæä¸¦èª¿ç”¨åˆ°postProcessBeanDefinitionRegistryæ–¹æ³•ã€‚

	```java
	public class MapperScannerConfigurer
	implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware
	```

	```java
	@Override
	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
		if (this.processPropertyPlaceHolders) {
			processPropertyPlaceHolders();
		}
		ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
		scanner.setAddToConfig(this.addToConfig);
		scanner.setAnnotationClass(this.annotationClass);
		scanner.setMarkerInterface(this.markerInterface);
		scanner.setSqlSessionFactory(this.sqlSessionFactory);
		scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
		scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
		scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
		scanner.setResourceLoader(this.applicationContext);
		scanner.setBeanNameGenerator(this.nameGenerator);
		scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);
		if (StringUtils.hasText(lazyInitialization)) {
			scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
		}
		scanner.registerFilters();
		scanner.scan(
			StringUtils.tokenizeToStringArray(this.basePackage,
			ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)
		);
	}
	```

	```java
	public int scan(String... basePackages) {
		int beanCountAtScanStart = this.registry.getBeanDefinitionCount();
		doScan(basePackages);
		// Register annotation config processors, if necessary.
		if (this.includeAnnotationConfig) {
			AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
		}
		return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
	}
	```

	```java
	@Override
	public Set<BeanDefinitionHolder> doScan(String... basePackages) {
		//è¿™ä¸ªæ–¹æ³•ä¸»è¦å°±æ³¨å†Œæ‰«æbasePackagesè·¯å¾„ä¸‹çš„mapperæ¥å£ï¼Œç„¶åå°è£…æˆä¸€ä¸ª
		BeanDefinitionååŠ å…¥åˆ°springå®¹å™¨ä¸­
		Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);
		if (beanDefinitions.isEmpty()) {
			LOGGER.warn(() -> "No MyBatis mapper was found in '" + Arrays.toString(basePackages) + "' package. Please check your configuration.");
		} else {
			//è¿™ä¸ªæ–¹æ³•ä¸»è¦ä¼šæŠŠåŸBeanDefinitionçš„beanClassç±»å‹ï¼Œä¿®æ”¹ä¸ºMapperFactoryBean
			processBeanDefinitions(beanDefinitions);
		}
		return beanDefinitions;
	}
	```

	ä¿®æ”¹äº†mapperçš„beanClassé¡å‹ç‚ºMapperFactoryBean
	
	```java
	private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {
		GenericBeanDefinition definition;
		for (BeanDefinitionHolder holder : beanDefinitions) {
			definition = (GenericBeanDefinition) holder.getBeanDefinition();
			String beanClassName = definition.getBeanClassName();
			LOGGER.debug(() -> "Creating MapperFactoryBean with name '" + holder.getBeanName() + "' and '" + beanClassName + "' mapperInterface");
			// the mapper interface is the original class of the bean
			// but, the actual class of the bean is MapperFactoryBean
			definition.getConstructorArgumentValues().addGenericArgumentValue(beanClass Name); // issue #59
			
			//ä¿®æ”¹beanClassç±»å‹
			definition.setBeanClass(this.mapperFactoryBeanClass);
			definition.getPropertyValues().add("addToConfig", this.addToConfig);
			boolean explicitFactoryUsed = false;
			if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) {
				definition.getPropertyValues().add("sqlSessionFactory",
				new RuntimeBeanReference(this.sqlSessionFactoryBeanName));
				explicitFactoryUsed = true;
			} else if (this.sqlSessionFactory != null) {
				definition.getPropertyValues().add("sqlSessionFactory",
				this.sqlSessionFactory);
				explicitFactoryUsed = true;
			}
			if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) {
				if (explicitFactoryUsed) {
					LOGGER.warn(
						() -> "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."
					);
				}
				definition.getPropertyValues().add("sqlSessionTemplate",
				new RuntimeBeanReference(this.sqlSessionTemplateBeanName));
				explicitFactoryUsed = true;
			} else if (this.sqlSessionTemplate != null) {
				if (explicitFactoryUsed) {
					LOGGER.warn(
						() -> "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.");
				}
				definition.getPropertyValues().add("sqlSessionTemplate",
				this.sqlSessionTemplate);
				explicitFactoryUsed = true;
			}
			
			if (!explicitFactoryUsed) {
				LOGGER.debug(() -> "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'.");
				definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
			}
							 
			definition.setLazyInit(lazyInitialization);
							 
		}
	}
	```

**ä¸Šè¿°å¹¾æ­¥ä¸»è¦æ˜¯å®Œæˆé€šé**

**@MapperScan(basePackages = â€œcom.mybatis.mapperâ€)é€™å€‹å®šç¾©ï¼ŒæƒææŒ‡å®šåŒ…ä¸‹çš„mapperæ¥å£ï¼Œç„¶å¾Œè¨­ç½®æ¯å€‹mapperæ¥å£çš„beanClasså±¬æ€§ç‚ºMapperFactoryBeané¡å‹ä¸¦åŠ å…¥åˆ°springçš„beanå®¹å™¨ä¸­ã€‚**

MapperFactoryBeanå¯¦ç¾äº†FactoryBeanæ¥å£ï¼Œæ‰€ä»¥ç•¶springå¾å¾…å¯¦ä¾‹åŒ–çš„beanå®¹å™¨ä¸­éæ­·åˆ°é€™å€‹beanä¸¦é–‹å§‹åŸ·è¡Œå¯¦ä¾‹åŒ–æ™‚è¿”å›çš„å°è±¡å¯¦éš›ä¸Šæ˜¯getObjectæ–¹æ³•ä¸­è¿”å›çš„å°è±¡ã€‚

```java
public class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T>
```

æœ€å¾Œçœ‹ä¸€ä¸‹MapperFactoryBeançš„getObjectæ–¹æ³•ï¼Œå¯¦éš›ä¸Šè¿”å›çš„å°±æ˜¯mybatisä¸­é€šégetMapperæ‹¿åˆ°çš„å°è±¡ï¼Œç†Ÿæ‚‰mybatisæºç¢¼çš„å°±æ‡‰è©²æ¸…æ¥šï¼Œé€™å€‹å°±æ˜¯mybatisé€šéå‹•æ…‹ä»£ç†ç”Ÿæˆçš„mapperæ¥å£å¯¦ç¾é¡'

```java
@Override public T getObject() throws Exception { return getSqlSession().getMapper(this.mapperInterface); }
```

åˆ°æ­¤ï¼Œmapperæ¥å£ç¾åœ¨ä¹Ÿé€šéå‹•æ…‹ä»£ç†ç”Ÿæˆäº†å¯¦ç¾é¡ï¼Œä¸¦ä¸”æ³¨å…¥åˆ°springçš„beanå®¹å™¨ä¸­äº†ï¼Œä¹‹å¾Œä½¿ç”¨è€…å°±å¯ä»¥é€šé@Autowiredæˆ–è€…getBeanç­‰æ–¹å¼ï¼Œå¾springå®¹å™¨ä¸­ç²å–åˆ°äº†



## 3.5 SpringBoot + Mybatiså¯¦ç¾å‹•æ…‹æ•¸æ“šæºåˆ‡æ›

### å‹•æ…‹æ•¸æ“šæºä»‹ç´¹

#### æ¥­å‹™èƒŒæ™¯
é›»å•†è¨‚å–®é …ç›®åˆ†æ­£å‘å’Œé€†å‘å…©å€‹éƒ¨åˆ†ï¼šå…¶ä¸­æ­£å‘æ•¸æ“šåº«è¨˜éŒ„äº†è¨‚å–®çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬è¨‚å–®åŸºæœ¬ä¿¡æ¯ã€è¨‚å–®å•†å“ä¿¡æ¯ã€å„ªæƒ å·ä¿¡æ¯ã€ç™¼ç¥¨ä¿¡æ¯ã€è³¬æœŸä¿¡æ¯ã€çµç®—ä¿¡æ¯ã€è¨‚å–®å‚™è¨»ä¿¡æ¯ã€æ”¶è²¨äººä¿¡æ¯ç­‰ï¼›é€†å‘æ•¸æ“šåº«ä¸»è¦åŒ…å«äº†å•†å“çš„é€€è²¨ä¿¡æ¯å’Œç¶­ä¿®ä¿¡æ¯ã€‚æ•¸æ“šé‡è¶…é500è¬è¡Œå°±è¦è€ƒæ…®åˆ†åº«åˆ†éŒ¶å’Œè®€å¯«åˆ†é›¢ï¼Œé‚£éº¼æˆ‘å€‘åœ¨æ­£å‘æ“ä½œå’Œé€†å‘æ“ä½œçš„æ™‚å€™ï¼Œå°±éœ€è¦å‹•æ…‹çš„åˆ‡æ›åˆ°ç›¸æ‡‰çš„æ•¸æ“šåº«ï¼Œé€²è¡Œç›¸é—œçš„æ“ä½œã€‚

#### è§£æ±ºæ€è·¯
ç¾åœ¨é …ç›®çš„çµæ§‹è¨­è¨ˆåŸºæœ¬ä¸Šæ˜¯åŸºæ–¼MVCçš„ï¼Œé‚£éº¼æ•¸æ“šåº«çš„æ“ä½œé›†ä¸­åœ¨daoå±¤å®Œæˆï¼Œä¸»è¦æ¥­å‹™é‚è¼¯åœ¨serviceå±¤è™•ç†ï¼Œcontrollerå±¤è™•ç†è«‹æ±‚ã€‚å‡è¨­åœ¨åŸ·è¡Œdaoå±¤ä»£ç¢¼ä¹‹å‰èƒ½å¤ å°‡æ•¸æ“šæºï¼ˆDataSourceï¼‰æ›æˆæˆ‘å€‘æƒ³è¦åŸ·è¡Œæ“ä½œçš„æ•¸æ“šæºï¼Œé‚£éº¼é€™å€‹å•é¡Œå°±è§£æ±ºäº†

#### åŸç†åœ–
![[Study_Matthew/SpringBoot/_annex/Pasted image 20211109160329.png]]

Springå…§ç½®äº†ä¸€å€‹AbstractRoutingDataSourceï¼Œå®ƒå¯ä»¥æŠŠå¤šå€‹æ•¸æ“šæºé…ç½®æˆä¸€å€‹Mapï¼Œç„¶å¾Œï¼Œæ ¹æ“šä¸åŒçš„keyè¿”å›ä¸åŒçš„æ•¸æ“šæºã€‚å› ç‚ºAbstractRoutingDataSourceä¹Ÿæ˜¯ä¸€å€‹DataSourceæ¥å£ï¼Œå› æ­¤ï¼Œæ‡‰ç”¨ç¨‹åºå¯ä»¥å…ˆè¨­ç½®å¥½keyï¼Œ è¨ªå•æ•¸æ“šåº«çš„ä»£ç¢¼å°±å¯ä»¥å¾AbstractRoutingDataSourceæ‹¿åˆ°å°æ‡‰çš„ä¸€å€‹çœŸå¯¦çš„æ•¸æ“šæºï¼Œå¾è€Œè¨ªå•æŒ‡å®šçš„æ•¸æ“šåº«

æŸ¥çœ‹AbstractRoutingDataSourceé¡ï¼š
```java
/**
* Abstract {@link javax.sql.DataSource} implementation that routes {@link
#getConnection()}
* calls to one of various target DataSources based on a lookup key. The
latter is usually
* (but not necessarily) determined through some thread-bound transaction
context.
*
* @author Juergen Hoeller
* @since 2.0.1
* @see #setTargetDataSources
* @see #setDefaultTargetDataSource
* @see #determineCurrentLookupKey()
*/
//ç¿»è¯‘ç»“æœå¦‚ä¸‹
/**
* æŠ½è±¡ {@link javax.sql.DataSource} è·¯ç”± {@link #getConnection ()} çš„å®ç°
* æ ¹æ®æŸ¥æ‰¾é”®è°ƒç”¨ä¸åŒçš„ç›®æ ‡æ•°æ®ä¹‹ä¸€ã€‚åè€…é€šå¸¸æ˜¯
* (ä½†ä¸ä¸€å®š) é€šè¿‡æŸäº›çº¿ç¨‹ç»‘å®šäº‹åŠ¡ä¸Šä¸‹æ–‡æ¥ç¡®å®šã€‚
*
* @author
* @since 2.0ã€‚1
* @see #setTargetDataSources
* @see #setDefaultTargetDataSource
* @see #determineCurrentLookupKey ()
*/
public abstract class AbstractRoutingDataSource extends AbstractDataSource
implements InitializingBean {
.......
/**
* Specify the map of target DataSources, with the lookup key as key.
* The mapped value can either be a corresponding {@link
javax.sql.DataSource}
* instance or a data source name String (to be resolved via a
* {@link #setDataSourceLookup DataSourceLookup}).
* <p>The key can be of arbitrary type; this class implements the
* generic lookup process only. The concrete key representation will
* be handled by {@link #resolveSpecifiedLookupKey(Object)} and
* {@link #determineCurrentLookupKey()}.
*/
//ç¿»è¯‘å¦‚ä¸‹
/**
*æŒ‡å®šç›®æ ‡æ•°æ®æºçš„æ˜ å°„ï¼ŒæŸ¥æ‰¾é”®ä¸ºé”®ã€‚
*æ˜ å°„çš„å€¼å¯ä»¥æ˜¯ç›¸åº”çš„{@link javax.sql.DataSource}
*å®ä¾‹æˆ–æ•°æ®æºåç§°å­—ç¬¦ä¸²ï¼ˆè¦é€šè¿‡
* {@link #setDataSourceLookup DataSourceLookup}ï¼‰ã€‚
*é”®å¯ä»¥æ˜¯ä»»æ„ç±»å‹çš„; è¿™ä¸ªç±»å®ç°äº†
*é€šç”¨æŸ¥æ‰¾è¿‡ç¨‹åªã€‚ å…·ä½“çš„å…³é”®è¡¨ç¤ºå°†
*ç”±{@link #resolveSpecifiedLookupKeyï¼ˆObjectï¼‰}å’Œ
* {@link #determineCurrentLookupKeyï¼ˆï¼‰}ã€‚
*/
	public void setTargetDataSources(Map<Object, Object> targetDataSources){
		this.targetDataSources = targetDataSources;
	}
......
/**
* Determine the current lookup key. This will typically be
* implemented to check a thread-bound transaction context.
* <p>Allows for arbitrary keys. The returned key needs
* to match the stored lookup key type, as resolved by the
* {@link #resolveSpecifiedLookupKey} method.
*/
//ç¿»è¯‘å¦‚ä¸‹
/**
* ç¡®å®šå½“å‰çš„æŸ¥æ‰¾é”®ã€‚è¿™é€šå¸¸ä¼š
* å®ç°ä»¥æ£€æŸ¥çº¿ç¨‹ç»‘å®šçš„äº‹åŠ¡ä¸Šä¸‹æ–‡ã€‚
* <p> å…è®¸ä»»æ„é”®ã€‚è¿”å›çš„å¯†é’¥éœ€è¦
* ä¸å­˜å‚¨çš„æŸ¥æ‰¾å¯†é’¥ç±»å‹åŒ¹é…, å¦‚
* {@link #resolveSpecifiedLookupKey} æ–¹æ³•ã€‚
*/
	protected abstract Object determineCurrentLookupKey();
}
```

ä¸Šé¢æºç¢¼ä¸­é‚„æœ‰å¦å¤–ä¸€å€‹æ ¸å¿ƒçš„æ–¹æ³• setTargetDataSources(Map<Object, Object>targetDataSources) ï¼Œå®ƒéœ€è¦ä¸€å€‹Mapï¼Œåœ¨æ–¹æ³•è¨»é‡‹ä¸­æˆ‘å€‘å¯ä»¥å¾—çŸ¥ï¼Œé€™å€‹Mapå­˜å„²çš„å°±æ˜¯æˆ‘å€‘é…ç½®çš„å¤šå€‹æ•¸æ“šæºçš„éµå€¼å°ã€‚æˆ‘å€‘æ•´ç†ä¸€ä¸‹é€™å€‹é¡åˆ‡æ›æ•¸æ“šæºçš„é‹ä½œæ–¹å¼ï¼Œé€™å€‹é¡åœ¨é€£æ¥æ•¸æ“šåº«ä¹‹å‰æœƒåŸ·è¡ŒdetermineCurrentLookupKey()æ–¹æ³•ï¼Œé€™å€‹æ–¹æ³•è¿”å›çš„æ•¸æ“šå°‡ä½œç‚ºkeyå»targetDataSourcesä¸­æŸ¥æ‰¾ç›¸æ‡‰çš„å€¼ï¼Œå¦‚æœæŸ¥æ‰¾åˆ°ç›¸å°æ‡‰çš„DataSourceï¼Œé‚£éº¼å°±ä½¿ç”¨æ­¤DataSourceç²å–æ•¸æ“šåº«é€£æ¥

å®ƒæ˜¯ä¸€å€‹abstracté¡ï¼Œæ‰€ä»¥æˆ‘å€‘ä½¿ç”¨çš„è©±ï¼Œæ¨è–¦çš„æ–¹å¼æ˜¯å‰µå»ºä¸€å€‹é¡ä¾†ç¹¼æ‰¿å®ƒä¸¦ä¸”å¯¦ç¾å®ƒçš„determineCurrentLookupKey() æ–¹æ³•ï¼Œé€™å€‹æ–¹æ³•ä»‹ç´¹ä¸Šé¢ä¹Ÿé€²è¡Œäº†èªªæ˜ï¼Œå°±æ˜¯é€šéé€™å€‹æ–¹æ³•é€²è¡Œæ•¸æ“šæºçš„åˆ‡æ›

#### ç’°å¢ƒæº–å‚™ï¼š
1. å¯¦é«”é¡
	```java
	public class Product {
		private Integer id;
		private String name;
		private Double price;
		public Integer getId() {
		    return id;
		}
		public void setId(Integer id) {
		    this.id = id;
		}
		public String getName() {
		    return name;
		}
		public void setName(String name) {
		    this.name = name;
		}
		public Double getPrice() {
		    return price;
		}
		public void setPrice(Double price) {
		    this.price = price;
		}
		@Override
		public String toString() {
		    return "Product{" +
		        "id=" + id +
		        ", name='" + name + '\'' +
		        ", price=" + price +
		        '}';
		}
	}

	```

2. ProductMapper
	```java
	public interface ProductMapper {
		
		@Select("select * from product")
		public List<Product> findAllProductM();
		
		@Select("select * from product")
		public List<Product> findAllProductS();
		
	}
	```

3. ProductService
	```java
	@Service
		public class ProductService {
		@Autowired
		private ProductMapper productMapper;
		public void findAllProductM(){
			// æŸ¥è¯¢Master
			List<Product> allProductM = productMapper.findAllProductM();
			System.out.println(allProductM);
		}
		public void findAllProductS(){
			// æŸ¥è¯¢Slave
			List<Product> allProductS = productMapper.findAllProductS();
			System.out.println(allProductS);
		}
	}
	```

4. ProductController
	```java
	@RestController
	public class ProductController {
		@Autowired
		private ProductService productService;
		
		@GetMapping("/findAllProductM")
		public String findAllProductM() {
			productService.findAllProductM();
			return "master";
		}
		
		@GetMapping("/findAllProductS")
		public String findAllProductS() {
			productService.findAllProductS();
			return "slave";
		}
	```

#### å…·é«”å¯¦ç¾
##### ç¬¬ä¸€æ­¥ï¼šé…ç½®å¤šæ•¸æ“šæº
é¦–å…ˆï¼Œæˆ‘å€‘åœ¨application.propertiesä¸­é…ç½®å…©å€‹æ•¸æ“šæº
```properties
spring.druid.datasource.master.password=root
spring.druid.datasource.master.username=root
spring.druid.datasource.master.jdbcurl=jdbc:mysql://localhost:3306/product_master?
useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
spring.druid.datasource.master.driver-class-name=com.mysql.cj.jdbc.Driver
spring.druid.datasource.slave.password=root
spring.druid.datasource.slave.username=root
spring.druid.datasource.slave.jdbcurl=jdbc:mysql://localhost:3306/product_slave?
useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
spring.druid.datasource.slave.driver-class-name=com.mysql.cj.jdbc.Driver
```

åœ¨SpringBootçš„é…ç½®ä»£ç¢¼ä¸­ï¼Œæˆ‘å€‘åˆå§‹åŒ–å…©å€‹æ•¸æ“šæºï¼š
```java
@Configuration
public class MyDataSourceConfiguratioin {
	Logger logger = LoggerFactory.getLogger(MyDataSourceConfiguratioin.class);
	/**
	* Master data source.
	*/
	@Bean("masterDataSource")
	@ConfigurationProperties(prefix = "spring.druid.datasource.master")
	DataSource masterDataSource() {
		logger.info("create master datasource...");
		return DataSourceBuilder.create().build();
	}
	/**
	* Slave data source.
	*/
	@Bean("slaveDataSource")
	@ConfigurationProperties(prefix = "spring.druid.datasource.slave")
	DataSource slaveDataSource() {
		logger.info("create slave datasource...");
		return DataSourceBuilder.create().build();
	}
}
```

##### ç¬¬äºŒæ­¥ï¼šç·¨å¯«RoutingDataSource
ç„¶å¾Œï¼Œæˆ‘å€‘ç”¨Springå…§ç½®çš„RoutingDataSourceï¼ŒæŠŠå…©å€‹çœŸå¯¦çš„æ•¸æ“šæºä»£ç†ç‚ºä¸€å€‹å‹•æ…‹æ•¸æ“šæº:
```java
public class RoutingDataSource extends AbstractRoutingDataSource {
	@Override
	protected Object determineCurrentLookupKey() {
		return "masterDataSource";
	}
}
```

,å°é€™å€‹ RoutingDataSource ï¼Œéœ€è¦åœ¨SpringBootä¸­é…ç½®å¥½ä¸¦è¨­ç½®ç‚ºä¸»æ•¸æ“šæºï¼š
```java
@Bean
@Primary
DataSource primaryDataSource(
@Autowired @Qualifier("masterDataSource") DataSource
masterDataSource,
@Autowired @Qualifier("slaveDataSource") DataSource
slaveDataSource
) {
	logger.info("create routing datasource...");
	Map<Object, Object> map = new HashMap<>();
	map.put("masterDataSource", masterDataSource);
	map.put("slaveDataSource", slaveDataSource);
	RoutingDataSource routing = new RoutingDataSource();
	routing.setTargetDataSources(map);
	routing.setDefaultTargetDataSource(masterDataSource);
	return routing;
}
```

ç¾åœ¨ï¼Œ RoutingDataSource é…ç½®å¥½äº†ï¼Œä½†æ˜¯ï¼Œè·¯ç”±çš„é¸æ“‡æ˜¯å¯«æ­»çš„ï¼Œå³æ°¸é è¿”å›"masterDataSource"

- ç¾åœ¨å•é¡Œä¾†äº†ï¼šå¦‚ä½•å­˜å„²å‹•æ…‹é¸æ“‡çš„keyä»¥åŠåœ¨å“ªè¨­ç½®keyï¼Ÿ

åœ¨Servletçš„ç·šç¨‹æ¨¡å‹ä¸­ï¼Œä½¿ç”¨ThreadLocalå­˜å„²keyæœ€åˆé©ï¼Œå› æ­¤ï¼Œæˆ‘å€‘ç·¨å¯«ä¸€å€‹RoutingDataSourceContext ï¼Œä¾†è¨­ç½®ä¸¦å‹•æ…‹å­˜å„²keyï¼š
```java
public class RoutingDataSourceContext {
	// holds data source key in thread local:
	static final ThreadLocal<String> threadLocalDataSourceKey = new	ThreadLocal<>();
	public static String getDataSourceRoutingKey() {
		String key = threadLocalDataSourceKey.get();
		return key == null ? "masterDataSource" : key;
	}
	public RoutingDataSourceContext(String key) {
		threadLocalDataSourceKey.set(key);
	}
	public void close() {
		threadLocalDataSourceKey.remove();
	}
}
```

ç„¶å¾Œï¼Œä¿®æ”¹ RoutingDataSource ï¼Œç²å–keyçš„ä»£ç¢¼å¦‚ä¸‹ï¼š
```java
public class RoutingDataSource extends AbstractRoutingDataSource {
	protected Object determineCurrentLookupKey() {
		return RoutingDataSourceContext.getDataSourceRoutingKey();
	}
}
```

é€™æ¨£ï¼Œåœ¨æŸå€‹åœ°æ–¹ï¼Œä¾‹å¦‚ä¸€å€‹Controllerçš„æ–¹æ³•å…§éƒ¨ï¼Œå°±å¯ä»¥å‹•æ…‹è¨­ç½®DataSourceçš„Keyï¼š
```java
@GetMapping("/findAllProductM")
public String findAllProductM() {
	String key = "masterDataSource";
	RoutingDataSourceContext routingDataSourceContext = new	RoutingDataSourceContext(key);
	productService.findAllProductM();
	return "master";
}
@GetMapping("/findAllProductS")
public String findAllProductS() {
	String key = "slaveDataSource";
	RoutingDataSourceContext routingDataSourceContext = new	RoutingDataSourceContext(key);
	productService.findAllProductS();
	return "slave";
}
```

åˆ°æ­¤ç‚ºæ­¢ï¼Œæˆ‘å€‘å·²ç¶“æˆåŠŸå¯¦ç¾äº†æ•¸æ“šåº«çš„å‹•æ…‹è·¯ç”±è¨ªå•ã€‚


##### å„ªåŒ–ï¼š
ä»¥ä¸Šä»£ç¢¼æ˜¯å¯è¡Œçš„ï¼Œä½†æ˜¯ï¼Œéœ€è¦è®€æ•¸æ“šåº«çš„åœ°æ–¹ï¼Œå°±éœ€è¦åŠ ä¸Šä¸€å¤§æ®µRoutingDataSourceContextctx = ...ä»£ç¢¼ï¼Œä½¿ç”¨èµ·ä¾†ååˆ†ä¸ä¾¿ã€‚æœ‰æ²’æœ‰æ–¹æ³•å¯ä»¥ç°¡åŒ–å‘¢ï¼Ÿ

æœ‰ï¼

æˆ‘å€‘ä»”ç´°æƒ³æƒ³ï¼ŒSpringæä¾›çš„è²æ˜å¼äº‹å‹™ç®¡ç†ï¼Œå°±åªéœ€è¦ä¸€å€‹ @Transactional() è¨»è§£ï¼Œæ”¾åœ¨æŸå€‹Javaæ–¹æ³•ä¸Šï¼Œé€™å€‹æ–¹æ³•å°±è‡ªå‹•å…·æœ‰äº†äº‹å‹™ã€‚

æˆ‘å€‘ä¹Ÿå¯ä»¥ç·¨å¯«ä¸€å€‹é¡ä¼¼çš„ @RoutingWith("slaveDataSource") è¨»è§£ï¼Œæ”¾åˆ°æŸå€‹Controllerçš„æ–¹æ³•ä¸Šï¼Œé€™å€‹æ–¹æ³•å…§éƒ¨å°±è‡ªå‹•é¸æ“‡äº†å°æ‡‰çš„æ•¸æ“šæºã€‚

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RoutingWith {
	String value() default "master";
}
```

ç·¨è­¯å‰éœ€è¦æ·»åŠ ä¸€å€‹Mavenä¾è³´ï¼š
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

åˆ‡é¢é¡ï¼š
```java
@Aspect
@Component
public class RoutingAspect {
	@Around("@annotation(routingWith)")
	public Object routingWithDataSource(ProceedingJoinPoint joinPoint, RoutingWith routingWith) throws Throwable {
		String key = routingWith.value();
		RoutingDataSourceContext ctx = new RoutingDataSourceContext(key);
		return joinPoint.proceed();
	}
}
```

æ³¨æ„æ–¹æ³•çš„ç¬¬äºŒå€‹åƒæ•¸RoutingWithæ˜¯Springå‚³å…¥çš„è¨»è§£å¯¦ä¾‹ï¼Œæˆ‘å€‘æ ¹æ“šè¨»è§£çš„value()ç²å–é…ç½®çš„keyã€‚

æ”¹é€ æ–¹æ³•ï¼š
```java
@RoutingWith("masterDataSource")
@GetMapping("/findAllProductM")
public String findAllProductM() {
	/* String key = "masterDataSource";
	RoutingDataSourceContext routingDataSourceContext = new
	RoutingDataSourceContext(key);*/
	productService.findAllProductM();
	return "lagou";
}

@RoutingWith("slaveDataSource")
@GetMapping("/findAllProductS")
public String findAllProductS() {
	/*String key = "slaveDataSource";
	RoutingDataSourceContext routingDataSourceContext = new
	RoutingDataSourceContext(key);*/
	productService.findAllProductS();
	return "lagou";
}

```

åˆ°æ­¤ç‚ºæ­¢ï¼Œæˆ‘å€‘å°±å¯¦ç¾äº†ç”¨è¨»è§£å‹•æ…‹é¸æ“‡æ•¸æ“šæºçš„åŠŸèƒ½




