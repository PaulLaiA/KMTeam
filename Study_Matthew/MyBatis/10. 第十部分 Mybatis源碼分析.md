---
date: 2021-11-04
aliases: []
---

# Metadata

**Title** :: Mybatis æºç¢¼åˆ†æ

**Author** :: #Matthew 

**Classification** :: #Learn #Java #Basic #MyBatis

**Status** :: #ğŸŒ±

**Type** :: #Note

**Previous** ::

**ParentNode** :: [[Study_Matthew/MyBatis/MyBatis|MyBatis]]

---
# ç¬¬åéƒ¨åˆ†ï¼š Mybatis æºç¢¼åˆ†æ

## 10.1 å‚³çµ±æ–¹å¼æºç¢¼åˆ†æ

**æºç å‰–æ-åˆå§‹åŒ–**
```java
Inputstream inputstream = Resources.getResourceAsStream("mybatis-config.xml");
//è¿™â¼€â¾ä»£ç æ­£æ˜¯åˆå§‹åŒ–â¼¯ä½œçš„å¼€å§‹ã€‚
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);
```

è¿›â¼Šæºç åˆ†æï¼š
```java
// 1.æˆ‘ä»¬æœ€åˆè°ƒâ½¤çš„ build
 public SqlSessionFactory build (InputStream inputStream){
 //è°ƒâ½¤äº†é‡è½½â½…æ³•
 return build(inputStream, null, null);
 }
 
 // 2.è°ƒâ½¤çš„é‡è½½â½…æ³•
 public SqlSessionFactory build (InputStream inputStream, String environment, Properties properties){
 try {
 // XMLConfigBuilder æ˜¯ä¸“â»”è§£æ mybatis çš„é…ç½®â½‚ä»¶çš„ç±»
 XMLConfigBuilder parser = new XMLConfigBuilder(inputstream,environment, properties);
 //è¿™â¾¥â¼œè°ƒâ½¤äº†â¼€ä¸ªé‡è½½â½…æ³•ã€‚parser.parse()çš„è¿”å›å€¼æ˜¯ Configuration å¯¹è±¡
 return build(parser.parse());
 } catch (Exception e) {
 throw ExceptionFactory.wrapException("Error building SqlSession.", e)
 }
```

MyBatis åœ¨åˆå§‹åŒ–çš„æ™‚å€™ï¼Œæœƒå°‡ MyBatis çš„é…ç½®ä¿¡æ¯å…¨éƒ¨åŠ è¼‰åˆ°å…§å­˜ä¸­ï¼Œä½¿â½¤ org.apache.ibatis.session.Configuratio n å¯¦ä¾‹ä¾†ç¶­è­·

ä¸‹â¾¯é€²â¼Šå°é…ç½®â½‚ä»¶è§£æéƒ¨åˆ†ï¼š

â¾¸å…ˆå° Configuration å°è±¡é€²â¾ä»‹ç´¹ï¼š

	Configuration å°è±¡çš„çµæ§‹å’Œ xml é…ç½®â½‚ä»¶çš„å°è±¡â¼ä¹ç›¸åŒã€‚
	å›é¡§â¼€ä¸‹ xml ä¸­çš„é…ç½®æ¨™ç±¤æœ‰å“ªäº›ï¼š
	properties (å±¬æ€§)ï¼Œsettings (è¨­ç½®)ï¼ŒtypeAliases (é¡å‹åˆ¥å)ï¼ŒtypeHandlers (é¡å‹è™•ç† å™¨)ï¼Œ
	objectFactory (å°è±¡â¼¯â¼š)ï¼Œmappers (æ˜ å°„å™¨)ç­‰ Configuration ä¹Ÿæœ‰å°æ‡‰çš„å°è±¡å±¬æ€§ä¾†å°è£å®ƒå€‘
	ä¹Ÿå°±æ˜¯èªªï¼Œåˆå§‹åŒ–é…ç½®â½‚ä»¶ä¿¡æ¯çš„æœ¬è³ªå°±æ˜¯å‰µå»º Configuration å°è±¡ï¼Œå°‡è§£æçš„ xml æ•¸æ“šå°è£åˆ° Configuration å…§éƒ¨å±¬æ€§ä¸­

```java
/**
 * è§£æ XML æˆ Configuration å¯¹è±¡ã€‚
 */
 public Configuration parse () {
	 //è‹¥å·²è§£æï¼ŒæŠ›å‡º BuilderException å¼‚å¸¸
	 if (parsed) {
	 	throw new BuilderException("Each XMLConfigBuilder can only be used once.");
	 }
	 //æ ‡è®°å·²è§£æ
	 parsed = true;
	 // è§£æ XML configuration èŠ‚ç‚¹
	 parseConfiguration(parser.evalNode("/configuration"));
	 return configuration;
}
	 /**
	 *è§£æ XML
	 */
private void parseConfiguration (XNode root){
 try {
	 //issue #117 read properties first
	 // è§£æ <properties /> æ ‡ç­¾
	 propertiesElement(root.evalNode("properties"));
	 // è§£æã€ˆsettings /> æ ‡ç­¾
	 Properties settings =
	 settingsAsProperties(root.evalNode("settings"));
	 //åŠ è½½â¾ƒå®šä¹‰çš„ VFS å®ç°ç±»
	 loadCustomVfs(settings);
	 // è§£æ <typeAliases /> æ ‡ç­¾
	 typeAliasesElement(root.evalNode("typeAliases"));
	 //è§£æ <plugins /> æ ‡ç­¾
	 pluginElement(root.evalNode("plugins"));
	 // è§£æ <objectFactory /> æ ‡ç­¾
	 objectFactoryElement(root.evalNode("objectFactory"));
	 // è§£æ <objectWrapperFactory /> æ ‡ç­¾
	 objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
	 // è§£æ <reflectorFactory /> æ ‡ç­¾
	 reflectorFactoryElement(root.evalNode("reflectorFactory"));
	 // èµ‹å€¼ <settings /> â¾„ Configuration å±æ€§
	 settingsElement(settings);
	 // read it after objectFactory and objectWrapperFactory issue #631
	 // è§£æã€ˆenvironments /> æ ‡ç­¾
	 environmentsElement(root.evalNode("environments"));
	 // è§£æ <databaseIdProvider /> æ ‡ç­¾
	 databaseldProviderElement(root.evalNode("databaseldProvider"));
	 // è§£æ <typeHandlers /> æ ‡ç­¾
	 typeHandlerElement(root.evalNode("typeHandlers"));
	 //è§£æ <mappers /> æ ‡ç­¾
	 mapperElement(root.evalNode("mappers"));
 } catch (Exception e) {
 	 throw new BuilderException("Error parsing SQL Mapper Configuration.Cause:" + e, e);
 }
}
```

ä»‹ç´¹â¼€ä¸‹ MappedStatement ï¼š

ä½œâ½¤ï¼šMappedStatement èˆ‡ Mapper é…ç½®â½‚ä»¶ä¸­çš„â¼€å€‹ select/update/insert/delete ç¯€é»ç›¸å°æ‡‰ã€‚

mapper ä¸­é…ç½®çš„æ¨™ç±¤éƒ½è¢«å°è£åˆ°äº†æ­¤å°åƒä¸­ï¼Œä¸»è¦â½¤é€”æ˜¯æè¿°â¼€æ¢ SQL èªå¥ã€‚

**åˆå§‹åŒ–éç¨‹ï¼š** å›é¡§å‰›é–‹ å§‹ä»‹ç´¹çš„åŠ è¼‰é…ç½®â½‚ä»¶çš„éç¨‹ä¸­ï¼Œæœƒå° mybatis-config.xm l ä¸­çš„å„å€‹æ¨™ç±¤éƒ½é€²â¾è§£æï¼Œå…¶ä¸­æœ‰ mappers æ¨™ç±¤â½¤ä¾†å¼•â¼Š mapper.xml â½‚ä»¶æˆ–è€…é…ç½® mapper æ¥â¼çš„â½¬éŒ„ã€‚
```xml
<select id="getUser" resultType="user" >
 select * from user where id=#{id}
</select>
```

é€™æ¨£çš„â¼€å€‹ select æ¨™ç±¤æœƒåœ¨åˆå§‹åŒ–é…ç½®â½‚ä»¶æ™‚è¢«è§£æå°è£æˆâ¼€å€‹ MappedStatement å°è±¡ï¼Œç„¶å¾Œå­˜å„²åœ¨ Configuration å°è±¡çš„ mappedStatements å±¬æ€§ä¸­ï¼Œ

mappedStatements æ˜¯â¼€å€‹ HashMapï¼Œå­˜å„²æ™‚ key = å…¨é™å®šé¡å + â½…æ³•åï¼Œvalue = å°æ‡‰çš„ MappedStatement å°è±¡ã€‚

åœ¨ configuration ä¸­å°æ‡‰çš„å±¬æ€§ç‚º
```java
Map<String, MappedStatement> mappedStatements = new StrictMap<MappedStatement> ("Mapped Statements collection")
```

åœ¨ XMLConfigBuilder ä¸­çš„è™•ç†ï¼š
```java
private void parseConfiguration(XNode root) {
	 try {
		 //çœç•¥å…¶ä»–æ ‡ç­¾çš„å¤„ç†
		 mapperElement(root.evalNode("mappers"));
	 } catch (Exception e) {
		 throw new BuilderException("Error parsing SQL Mapper Configuration. Cause:" + e, e);
	 }
}
```

åˆ°æ­¤å° xml é…ç½®â½‚ä»¶çš„è§£æå°±çµæŸäº†ï¼Œå›åˆ°æ­¥é©Ÿ 2.ä¸­èª¿â½¤çš„é‡è¼‰ build â½…æ³•

```java
// 5.èª¿â½¤çš„é‡è¼‰â½…æ³•
public SqlSessionFactory build(Configuration config) {
 //å‰µå»ºäº† DefaultSqlSessionFactory å°è±¡ï¼Œå‚³â¼Š Configuration å°è±¡ã€‚
 return new DefaultSqlSessionFactory(config);
}
```


**æºç¢¼å‰–æ-åŸ·â¾ SQL æµç¨‹**

å…ˆç°¡å–®ä»‹ç´¹ SqlSession ï¼š

SqlSession æ˜¯â¼€å€‹æ¥â¼ï¼Œå®ƒæœ‰å…©å€‹å¯¦ç¾é¡ï¼šDefaultSqlSession (é»˜èª)å’Œ

SqlSessionManager (æ£„â½¤ï¼Œä¸åšä»‹ç´¹)

SqlSession æ˜¯ MyBatis ä¸­â½¤æ–¼å’Œæ•¸æ“šåº«äº¤äº’çš„é ‚å±¤é¡ï¼Œé€šå¸¸å°‡å®ƒèˆ‡ ThreadLocal ç¶å®šï¼Œâ¼€å€‹æœƒè©±ä½¿â½¤â¼€ å€‹ SqlSession,ä¸¦ä¸”åœ¨ä½¿â½¤å®Œç•¢å¾Œéœ€è¦ close
```java
public class DefaultSqlSession implements SqlSession {
	private final Configuration configuration;
	private final Executor executor;
}
```

SqlSession ä¸­çš„å…©å€‹æœ€é‡è¦çš„åƒæ•¸ï¼Œconfiguration èˆ‡åˆå§‹åŒ–æ™‚çš„ç›¸åŒï¼ŒExecutor ç‚ºåŸ·â¾å™¨

Executorï¼š

Executor ä¹Ÿæ˜¯â¼€å€‹æ¥â¼ï¼Œä»–æœ‰ä¸‰å€‹å¸¸â½¤çš„å¯¦ç¾é¡ï¼š

BatchExecutor (é‡â½¤èªå¥ä¸¦åŸ·â¾æ‰¹é‡æ›´æ–°)

ReuseExecutor (é‡â½¤é è™•ç†èªå¥ prepared statements)

SimpleExecutor (æ™®é€šçš„åŸ·â¾å™¨ï¼Œé»˜èª)

ç¹¼çºŒåˆ†æï¼Œåˆå§‹åŒ–å®Œç•¢å¾Œï¼Œæˆ‘å€‘å°±è¦åŸ·â¾ SQL äº†
```java
SqlSession sqlSession = factory.openSession();
List<User> list = sqlSession.selectList("com.lagou.mapper.UserMapper.getUserByName");
```

ç²å¾— sqlSession
```java
 //6. è¿›â¼Š o penSession â½…æ³•ã€‚
 public SqlSession openSession() {
 //getDefaultExecutorType()ä¼ é€’çš„æ˜¯ SimpleExecutor
 	return openSessionFromDataSource(configuration.getDefaultExecutorType(), null,false);
 }

 //7. è¿›â¼Š penSessionFromDataSourceã€‚
 //ExecutorType ä¸º Executor çš„ç±»å‹ï¼ŒTransactionIsolationLevel ä¸ºäº‹åŠ¡éš”ç¦»çº§åˆ«ï¼Œ autoCommit æ˜¯å¦å¼€å¯äº‹åŠ¡
 //openSession çš„å¤šä¸ªé‡è½½â½…æ³•å¯ä»¥æŒ‡å®šè·å¾—çš„ SeqSession çš„ Executor ç±»å‹å’Œäº‹åŠ¡çš„å¤„ç† 
private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
 Transaction tx = null;
 try{
	 final Environment environment = configuration.getEnvironment();
	 final TransactionFactory transactionFactory =  getTransactionFactoryFromEnvironment(environment);
	 tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
	 //æ ¹æ®å‚æ•°åˆ›å»ºæŒ‡å®šç±»å‹çš„ Executor
	 final Executor executor = configuration.newExecutor(tx, execType);
	 //è¿”å›çš„æ˜¯ DefaultSqlSession
	 return new DefaultSqlSession(configuration, executor, autoCommit);
 } catch(Exception e){
 closeTransaction(tx); // may have fetched a connection so lets call close()
 }
```

åŸ·â¾ sqlsession ä¸­çš„ api
```java
  //8.è¿›â¼Š selectList â½…æ³•ï¼Œå¤šä¸ªé‡è½½â½…æ³•ã€‚
 public <E > List < E > selectList(String statement) {
 	return this.selectList(statement, null);
 }
 public <E > List < E > selectList(String statement, Object parameter) {
 	return this.selectList(statement, parameter, RowBounds.DEFAULT);
 }
 public <E > List < E > selectList(String statement, Object parameter, RowBounds rowBounds) {
	 try {
	 //æ ¹æ®ä¼ â¼Šçš„å…¨é™å®šå + â½…æ³•åä»æ˜ å°„çš„ Map ä¸­å–å‡º MappedStatement å¯¹è±¡
	 MappedStatement ms = configuration.getMappedStatement(statement);
	 //è°ƒâ½¤ Executor ä¸­çš„â½…æ³•å¤„ç†
	 //RowBounds æ˜¯â½¤æ¥é€»è¾‘åˆ†â»š
	 // wrapCollection(parameter)æ˜¯â½¤æ¥è£…é¥°é›†åˆæˆ–è€…æ•°ç»„å‚æ•°
	 return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
	 } catch (Exception e) {
	 throw ExceptionFactory.wrapException("Error querying database. Cause: + e, e);
	 } finally {
	 ErrorContext.instance().reset();
 }
```

**æºç¢¼å‰–æ-executor**

ç¹¼çºŒæºç¢¼ä¸­çš„æ­¥é©Ÿï¼Œé€²â¼Š executor.query()
```java
 //æ­¤â½…æ³•åœ¨ SimpleExecutor çš„â½—ç±» BaseExecutor ä¸­å®ç°
 public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
 //æ ¹æ®ä¼ â¼Šçš„å‚æ•°åŠ¨æ€è·å¾— SQL è¯­å¥ï¼Œæœ€åè¿”å›â½¤ BoundSql å¯¹è±¡è¡¨ç¤º
 BoundSql boundSql = ms.getBoundSql(parameter);
 //ä¸ºæœ¬æ¬¡æŸ¥è¯¢åˆ›å»ºç¼“å­˜çš„ Key
 CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
 return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
 }
 //è¿›â¼Š query çš„é‡è½½â½…æ³•ä¸­
 public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds,
 ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
 ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
	 if (closed) {
		throw new ExecutorException("Executor was closed.");
	 }
	 if (queryStack == 0 && ms.isFlushCacheRequired()) {
		clearLocalCache();
	 }
	 List<E> list;
	 try {
		 queryStack++;
		 list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;
		 if (list != null) {
		 handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
		 } else {
		 //å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰æœ¬æ¬¡æŸ¥æ‰¾çš„å€¼ï¼Œé‚£ä¹ˆä»æ•°æ®åº“ä¸­æŸ¥è¯¢
		 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
	 }
	 } finally {
		 queryStack--;
	 }
	 if (queryStack == 0) {
	 for (DeferredLoad deferredLoad : deferredLoads) {
		 deferredLoad.load();
		 }
		 // issue #601
		 deferredLoads.clear();
		 if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) { //issue #482 clearLocalCache();
		 }
	 }
	 return list;
 }
 //ä»æ•°æ®åº“æŸ¥è¯¢
 private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
	 List<E> list;
	 localCache.putObject(key, EXECUTION_PLACEHOLDER);
	 try {
		 //æŸ¥è¯¢çš„â½…æ³•
		 list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
		 } finally {
		 localCache.removeObject(key);
	 }
	 //å°†æŸ¥è¯¢ç»“æœæ”¾â¼Šç¼“å­˜
	 localCache.putObject(key, list);
	 if (ms.getStatementType() == StatementType.CALLABLE) {
	 	localOutputParameterCache.putObject(key, parameter);
	 }
 	return list;
 }
 // SimpleExecutor ä¸­å®ç°â½—ç±»çš„ doQuery æŠ½è±¡â½…æ³•
 public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
	 Statement stmt = null;
	 try {
		 Configuration configuration = ms.getConfiguration();
		 //ä¼ â¼Šå‚æ•°åˆ›å»º StatementHanlder å¯¹è±¡æ¥æ‰§â¾æŸ¥è¯¢
		 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
		 //åˆ›å»º jdbc ä¸­çš„ statement å¯¹è±¡
		 stmt = prepareStatement(handler, ms.getStatementLog());
		 // StatementHandler è¿›â¾å¤„ç†
		 return handler.query(stmt, resultHandler);
	 } finally {
	 	closeStatement(stmt);
	 }
	 }
	 //åˆ›å»º Statement çš„â½…æ³•
	 private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
		 Statement stmt;
		 //æ¡ä»£ç ä¸­çš„ getConnection â½…æ³•ç»è¿‡é‡é‡è°ƒâ½¤æœ€åä¼šè°ƒâ½¤ openConnection â½…æ³•ï¼Œä»è¿æ¥æ± ä¸­è· å¾—è¿æ¥ã€‚
		 Connection connection = getConnection(statementLog);
		 stmt = handler.prepare(connection, transaction.getTimeout());
		 handler.parameterize(stmt);
	 return stmt;
 }
 //ä»è¿æ¥æ± è·å¾—è¿æ¥çš„â½…æ³•
 protected void openConnection() throws SQLException {
	 if (log.isDebugEnabled()) {
	 	log.debug("Opening JDBC Connection");
	 }
	 //ä»è¿æ¥æ± è·å¾—è¿æ¥
	 connection = dataSource.getConnection();
	 if (level != null) {
	 	connection.setTransactionIsolation(level.getLevel());
	 }
 }
```

ä¸Šè¿°çš„ Executor.query()â½…æ³•â¼ç¶“è½‰æŠ˜ï¼Œæœ€å¾Œæœƒå‰µå»ºâ¼€å€‹ StatementHandler å°è±¡ï¼Œç„¶å¾Œå°‡å¿…è¦çš„åƒæ•¸å‚³éçµ¦ StatementHandlerï¼Œä½¿â½¤ StatementHandler ä¾†å®Œæˆå°æ•¸æ“šåº«çš„æŸ¥è©¢ï¼Œæœ€çµ‚è¿”å› List çµæœé›†ã€‚

å¾ä¸Šâ¾¯çš„ä»£ç¢¼ä¸­æˆ‘å€‘å¯ä»¥çœ‹å‡ºï¼ŒExecutor çš„åŠŸèƒ½å’Œä½œâ½¤æ˜¯ï¼š

	(1ã€æ ¹æ“šå‚³éçš„åƒæ•¸ï¼Œå®Œæˆ SQL èªå¥çš„å‹•æ…‹è§£æï¼Œâ½£æˆ BoundSql å°è±¡ï¼Œä¾› StatementHandler ä½¿â½¤ï¼›
	(2ã€ç‚ºæŸ¥è©¢å‰µå»ºç·©å­˜ï¼Œä»¥æâ¾¼æ€§èƒ½
	(3ã€å‰µå»º JDBC çš„ Statement é€£æ¥å°è±¡ï¼Œå‚³éçµ¦*StatementHandler*å°è±¡ï¼Œè¿”å› List æŸ¥è©¢çµæœã€‚
	
**æºç¢¼å‰–æ-StatementHandler**

StatementHandler å°è±¡ä¸»è¦å®Œæˆå…©å€‹â¼¯ä½œï¼š

- å°æ–¼ JDBC çš„ PreparedStatement é¡å‹çš„å°è±¡ï¼Œå‰µå»ºçš„éç¨‹ä¸­ï¼Œæˆ‘å€‘ä½¿â½¤çš„æ˜¯ SQL èªå¥å­—ç¬¦ä¸²æœƒåŒ…å«è‹¥â¼²å€‹ï¼Ÿä½”ä½ç¬¦ï¼Œæˆ‘å€‘å…¶å¾Œå†å°å ä½ç¬¦é€²â¾è¨­å€¼ã€‚ StatementHandler é€šé parameterize(statement)â½…æ³•å° S tatement é€²â¾è¨­å€¼ï¼›

- StatementHandler é€šé List query(Statement statement, ResultHandler resultHandler)â½…æ³•ä¾† å®ŒæˆåŸ·â¾ Statementï¼Œå’Œå°‡ Statement å°è±¡è¿”å›çš„ resultSet å°è£æˆ Listï¼›

é€²â¼Šåˆ° StatementHandler çš„ parameterize(statement)â½…æ³•çš„å¯¦ç¾ï¼š
```java
public void parameterize(Statement statement) throws SQLException {
 //ä½¿â½¤ ParameterHandler å¯¹è±¡æ¥å®Œæˆå¯¹ Statement çš„è®¾å€¼
 parameterHandler.setParameters((PreparedStatement) statement);
}
```

```java
 /** ParameterHandler ç±»çš„ setParameters(PreparedStatement ps) å®ç°
 * å¯¹æŸâ¼€ä¸ª Statement è¿›â¾è®¾ç½®å‚æ•°
 * */
public void setParameters(PreparedStatement ps) throws SQLException {
	ErrorContext.instance().activity("setting parameters").object(mappedStatement.getParameterMap().getId());
	List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();
	 if (parameterMappings != null) { 
		 for (int i = 0; i < parameterMappings.size(); i++) { 
			 ParameterMapping parameterMapping = parameterMappings.get(i); 
			 if(parameterMapping.getMode() != ParameterMode.OUT) { 
				 Object value;
				 String propertyName = parameterMapping.getProperty();
				 if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask irst for additional params
					 value = boundSql.getAdditionalParameter(propertyName);
				 } else if (parameterObject == null) { 
					 value = null;
				 } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())){ 
					 value = parameterObject;
				 } else {
					 MetaObject metaObject = configuration.newMetaObject(parameterObject);
					 value = metaObject.getValue(propertyName); 
				 }
				 // æ¯â¼€ä¸ª Mapping éƒ½æœ‰â¼€ä¸ª TypeHandlerï¼Œæ ¹æ® TypeHandler æ¥å¯¹ preparedStatement è¿› â¾è®¾ç½®å‚æ•°
				 TypeHandler typeHandler = parameterMapping.getTypeHandler();
				 JdbcType jdbcType = parameterMapping.getJdbcType();
				 if (value == null && jdbcType == null) jdbcType =configuration.getJdbcTypeForNull();
				 //è®¾ç½®å‚æ•°
				 typeHandler.setParameter(ps, i + 1, value, jdbcType);
			 }
		 }
	 }
 }
```

å¾ä¸Šè¿°çš„ä»£ç¢¼å¯ä»¥çœ‹åˆ°,StatementHandler çš„ parameterize(Statement)â½…æ³•èª¿â½¤äº†

ParameterHandler çš„ setParameters(statement)â½…æ³•ï¼Œ

ParameterHandler çš„ setParameters(Statement )â½…æ³•è² è²¬æ ¹æ“šæˆ‘å€‘è¼¸â¼Šçš„åƒæ•¸ï¼Œå° statement å°è±¡çš„ ?ä½”ä½ç¬¦è™•é€²â¾è³¦å€¼ã€‚

é€²â¼Šåˆ° StatementHandler çš„ List query(Statement statement, ResultHandler resultHandler)â½…æ³•çš„ å¯¦ç¾ï¼š
```java
public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {
 // 1.è°ƒâ½¤ preparedStatemntã€‚execute()â½…æ³•ï¼Œç„¶åå°† resultSet äº¤ç»™ ResultSetHandler å¤„ç†
 PreparedStatement ps = (PreparedStatement) statement;
 ps.execute();
 
 //2.ä½¿â½¤ ResultHandler æ¥å¤„ç† ResultSet
 return resultSetHandler.<E> handleResultSets(ps);
}
```

å¾ä¸Šè¿°ä»£ç¢¼æˆ‘å€‘å¯ä»¥çœ‹å‡ºï¼ŒStatementHandler çš„ List query(Statement statement, ResultHandler resultHandler)â½…æ³•çš„å¯¦ç¾ï¼Œæ˜¯èª¿â½¤äº† ResultSetHandler çš„ handleResultSets(Statement)â½…æ³•ã€‚

ResultSetHandler çš„ handleResultSets(Statement)â½…æ³•æœƒå°‡ Statement èªå¥åŸ·â¾å¾Œâ½£æˆçš„ resultSet çµ æœé›†è½‰æ›æˆ List çµæœé›†
```java
public List<Object> handleResultSets(Statement stmt) throws SQLException {
 ErrorContext.instance().activity("handling results").object(mappedStatement.getId());
 //å¤š ResultSet çš„ç»“æœé›†åˆï¼Œæ¯ä¸ª ResultSet å¯¹åº”â¼€ä¸ª Object å¯¹è±¡ã€‚â½½å®é™…ä¸Šï¼Œæ¯ ä¸ª Object æ˜¯ List<Object> å¯¹è±¡ã€‚
 //åœ¨ä¸è€ƒè™‘å­˜å‚¨è¿‡ç¨‹çš„å¤š ResultSet çš„æƒ…å†µï¼Œæ™®é€šçš„æŸ¥è¯¢ï¼Œå®é™…å°±â¼€ä¸ª ResultSetï¼Œä¹Ÿ å°±æ˜¯è¯´ï¼ŒmultipleResults æœ€å¤šå°±â¼€ä¸ªå…ƒç´ ã€‚
 final List<Object> multipleResults = new ArrayList<>();
 int resultSetCount = 0;
 //è·å¾—â¾¸ä¸ª ResultSet å¯¹è±¡ï¼Œå¹¶å°è£…æˆ ResultSetWrapper å¯¹è±¡
 ResultSetWrapper rsw = getFirstResultSet(stmt);
 //è·å¾— ResultMap æ•°ç»„
 //åœ¨ä¸è€ƒè™‘å­˜å‚¨è¿‡ç¨‹çš„å¤š ResultSet çš„æƒ…å†µï¼Œæ™®é€šçš„æŸ¥è¯¢ï¼Œå®é™…å°±â¼€ä¸ª ResultSetï¼Œä¹Ÿ å°±æ˜¯è¯´ï¼ŒresultMaps å°±â¼€ä¸ªå…ƒç´ ã€‚
 List<ResultMap> resultMaps = mappedStatement.getResultMaps();
 int resultMapCount = resultMaps.size();
 validateResultMapsCount(rsw, resultMapCount); // æ ¡éªŒ
 while (rsw != null && resultMapCount > resultSetCount) {
	 //è·å¾— ResultMap å¯¹è±¡
	 ResultMap resultMap = resultMaps.get(resultSetCount);
	 //å¤„ç† ResultSetï¼Œå°†ç»“æœæ·»åŠ åˆ° multipleResults ä¸­
	 handleResultSet(rsw, resultMap, multipleResults, null);
	 //è·å¾—ä¸‹â¼€ä¸ª ResultSet å¯¹è±¡ï¼Œå¹¶å°è£…æˆ ResultSetWrapper å¯¹è±¡
	 rsw = getNextResultSet(stmt);
	 //æ¸…ç†
	 cleanUpAfterHandlingResultSet();
	 // resultSetCount ++
	 resultSetCount++;
 }
 }
 //å› ä¸º'mappedStatement.resultSets'åªåœ¨å­˜å‚¨è¿‡ç¨‹ä¸­ä½¿â½¤ï¼Œæœ¬ç³»åˆ—æš‚æ—¶ä¸è€ƒè™‘ï¼Œå¿½ç•¥å³å¯
 String[] resultSets = mappedStatement.getResultSets();
 if(resultSets!=null) {
	 while (rsw != null && resultSetCount < resultSets.length) {
	 ResultMapping parentMapping =
	 nextResultMaps.get(resultSets[resultSetCount]);
	 if (parentMapping != null) {
		 String nestedResultMapId = parentMapping.getNestedResultMapId();
		 ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
		 handleResultSet(rsw, resultMap, null, parentMapping);
 	 }
	 rsw = getNextResultSet(stmt);
	 cleanUpAfterHandlingResultSet();
	 resultSetCount++;
 }
 }
 //å¦‚æœæ˜¯ multipleResults å•å…ƒç´ ï¼Œåˆ™å–â¾¸å…ƒç´ è¿”å›
 return collapseSingleResultList(multipleResults);
}
```

## 10.2 Mapper ä»£ç†â½…å¼ï¼š
å›é¡§ä¸‹å¯«æ³•:
```java
 public static void main(String[] args) {
	 //å‰ä¸‰æ­¥éƒ½ç›¸åŒ
	 InputStream inputStream = Resources.getResourceAsStream("sqlMapConfig.xml");
	 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);
	 SqlSession sqlSession = factory.openSession();
	 //è¿™â¾¥ä¸å†è°ƒâ½¤ SqlSession çš„ api,â½½æ˜¯è·å¾—äº†æ¥â¼å¯¹è±¡ï¼Œè°ƒâ½¤æ¥â¼ä¸­çš„â½…æ³•ã€‚
	 UserMapper mapper = sqlSession.getMapper(UserMapper.class);
	 List<User> list = mapper.getUserByName("tom");
 }
```

æ€è€ƒâ¼€å€‹å•é¡Œï¼Œé€šå¸¸çš„ Mapper æ¥â¼æˆ‘å€‘éƒ½æ²’æœ‰å¯¦ç¾çš„â½…æ³•å»å¯ä»¥ä½¿â½¤ï¼Œæ˜¯ç‚ºä»€éº¼å‘¢ï¼Ÿ

ç­”æ¡ˆå¾ˆç°¡å–®å‹•æ…‹ ä»£ç†é–‹å§‹ä¹‹å‰ä»‹ç´¹â¼€ä¸‹ MyBatis åˆå§‹åŒ–æ™‚å°æ¥â¼çš„è™•ç†ï¼šMapperRegistry æ˜¯ Configuration ä¸­çš„â¼€å€‹å±¬æ€§ï¼Œå®ƒå…§éƒ¨ç¶­è­·â¼€å€‹ HashMap â½¤æ–¼å­˜æ”¾ mapper æ¥â¼çš„â¼¯â¼šé¡ï¼Œæ¯å€‹æ¥â¼å°æ‡‰â¼€å€‹â¼¯â¼šé¡ã€‚ 

mappers ä¸­å¯ä»¥ é…ç½®æ¥â¼çš„åŒ…è·¯å¾‘ï¼Œæˆ–è€…æŸå€‹å…·é«”çš„æ¥â¼é¡ã€‚

```xml
<mappers>
 <mapper class="com.lagou.mapper.UserMapper"/>
 <package name="com.lagou.mapper"/>
</mappers>
```

ç•¶è§£æ mappers æ¨™ç±¤æ™‚ï¼Œå®ƒæœƒåˆ¤æ–·è§£æåˆ°çš„æ˜¯ mapper é…ç½®â½‚ä»¶æ™‚ï¼Œæœƒå†å°‡å°æ‡‰é…ç½®â½‚ä»¶ä¸­çš„å¢åˆª æ”¹æŸ¥æ¨™ç±¤å°è£æˆ MappedStatement å°è±¡ï¼Œå­˜â¼Š mappedStatements ä¸­ã€‚

(ä¸Šâ½‚ä»‹ç´¹äº†)ç•¶åˆ¤æ–·è§£æåˆ°æ¥â¼æ™‚ï¼Œæœƒå»ºæ­¤æ¥â¼å°æ‡‰çš„ MapperProxyFactory å°è±¡ï¼Œå­˜â¼Š HashMap ä¸­ï¼Œkey = æ¥â¼çš„å­—ç¯€ç¢¼å°è±¡ï¼Œvalue = æ­¤æ¥â¼å°æ‡‰çš„ MapperProxyFactory å°è±¡ã€‚

**æºç¢¼å‰–æ-getmapper()**

é€²â¼Š sqlSession.getMapper(UserMapper.class )ä¸­
```java
//DefaultSqlSession ä¸­çš„ getMapper
 public <T> T getMapper(Class<T> type) {
 	return configuration.<T>getMapper(type, this);
 }
 //configuration ä¸­çš„ç»™ g etMapper
 public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
 	return mapperRegistry.getMapper(type, sqlSession);
 }
 //MapperRegistry ä¸­çš„ g etMapper
 public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
	 //ä» MapperRegistry ä¸­çš„ HashMap ä¸­æ‹¿ MapperProxyFactory
	 final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);
	 if (mapperProxyFactory == null) {
	 throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
	 }
	 try {
	 //é€šè¿‡åŠ¨æ€ä»£ç†â¼¯â¼šâ½£æˆç¤ºä¾‹ã€‚
	 return mapperProxyFactory.newInstance(sqlSession);
	 } catch (Exception e) {
	 throw new BindingException("Error getting mapper instance. Cause: " + e, e);
	 }
 }
 //MapperProxyFactory ç±»ä¸­çš„ newInstance â½…æ³•
 public T newInstance(SqlSession sqlSession) {
	 //åˆ›å»ºäº† JDK åŠ¨æ€ä»£ç†çš„ Handler ç±»
	 final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);
	 //è°ƒâ½¤äº†é‡è½½â½…æ³•
	 return newInstance(mapperProxy);
 }
 //MapperProxy ç±»ï¼Œå®ç°äº† InvocationHandler æ¥â¼
 public class MapperProxy<T> implements InvocationHandler, Serializable {
	 //çœç•¥éƒ¨åˆ†æºç 
	 private final SqlSession sqlSession;
	 private final Class<T> mapperInterface;
	 private final Map<Method, MapperMethod> methodCache;
	 //æ„é€ ï¼Œä¼ â¼Šäº† SqlSessionï¼Œè¯´æ˜æ¯ä¸ª session ä¸­çš„ä»£ç†å¯¹è±¡çš„ä¸åŒçš„ï¼
	 public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache) {
		 this.sqlSession = sqlSession;
		 this.mapperInterface = mapperInterface;
		 this.methodCache = methodCache;
 	 }
 //çœç•¥éƒ¨åˆ†æºç 
}
```

**æºç¢¼å‰–æ-invoke()**

åœ¨å‹•æ…‹ä»£ç†è¿”å›äº†ç¤ºä¾‹å¾Œï¼Œæˆ‘å€‘å°±å¯ä»¥ç›´æ¥èª¿â½¤ mapper é¡ä¸­çš„â½…æ³•äº†ï¼Œä½†ä»£ç†å°è±¡èª¿â½¤â½…æ³•ï¼ŒåŸ·â¾æ˜¯åœ¨ MapperProxy ä¸­çš„ invoke â½…æ³•ä¸­

```java
 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	 try {
	 //å¦‚æœæ˜¯ Object å®šä¹‰çš„â½…æ³•ï¼Œç›´æ¥è°ƒâ½¤
		 if (Object.class.equals(method.getDeclaringClass())) {
			return method.invoke(this, args);
		 } else if (isDefaultMethod(method)) {
			return invokeDefaultMethod(proxy, method, args);
		 }
	 } catch (Throwable t) {
	 	throw ExceptionUtil.unwrapThrowable(t);
	 }
	 // è·å¾— MapperMethod å¯¹è±¡
	 final MapperMethod mapperMethod = cachedMapperMethod(method);
	 //é‡ç‚¹åœ¨è¿™ï¼šMapperMethod æœ€ç»ˆè°ƒâ½¤äº†æ‰§â¾çš„â½…æ³•
	 return mapperMethod.execute(sqlSession, args);
 }
```

é€²â¼Š execute â½…æ³•ï¼š
```java
public Object execute(SqlSession sqlSession, Object[] args) {
 Object result;
 //åˆ¤æ–­ mapper ä¸­çš„â½…æ³•ç±»å‹ï¼Œæœ€ç»ˆè°ƒâ½¤çš„è¿˜æ˜¯ SqlSession ä¸­çš„â½…æ³• 
 switch (command.getType()) {
	 case INSERT: {
		 //è½¬æ¢å‚æ•°
		 Object param = method.convertArgsToSqlCommandParam(args);
		 //æ‰§â¾ INSERT æ“ä½œ
		 // è½¬æ¢ rowCount
		 result = rowCountResult(sqlSession.insert(command.getName(), param));
		 break;
	 }
	 case UPdate: {
		 //è½¬æ¢å‚æ•°
		 Object param = method.convertArgsToSqlCommandParam(args);
		 // è½¬æ¢ rowCount
		 result = rowCountResult(sqlSession.update(command.getName(), param));
		 break;
	 }
	 case DELETE: {
		 //è½¬æ¢å‚æ•°
		 Object param = method.convertArgsToSqlCommandParam(args);
		 // è½¬æ¢ rowCount
		 result = rowCountResult(sqlSession.delete(command.getName(),
		 param));
		 break;
	 }
	 case SELECT:
		 //â½†è¿”å›ï¼Œå¹¶ä¸”æœ‰ ResultHandler â½…æ³•å‚æ•°ï¼Œåˆ™å°†æŸ¥è¯¢çš„ç»“æœï¼Œæäº¤ç»™ ResultHandler è¿›â¾å¤„ç†
		 if (method.returnsVoid() && method.hasResultHandler()) {
			 executeWithResultHandler(sqlSession, args);
			 result = null;
		 //æ‰§â¾æŸ¥è¯¢ï¼Œè¿”å›åˆ—è¡¨
		 } else if (method.returnsMany()) {
		   result = executeForMany(sqlSession, args);
		 //æ‰§â¾æŸ¥è¯¢ï¼Œè¿”å› Map
		 } else if (method.returnsMap()) {
		   result = executeForMap(sqlSession, args);
		 //æ‰§â¾æŸ¥è¯¢ï¼Œè¿”å› Cursor
		 } else if (method.returnsCursor()) {
		   result = executeForCursor(sqlSession, args);
		 //æ‰§â¾æŸ¥è¯¢ï¼Œè¿”å›å•ä¸ªå¯¹è±¡
		 } else {
			 //è½¬æ¢å‚æ•°
			 Object param = method.convertArgsToSqlCommandParam(args);
			 //æŸ¥è¯¢å•æ¡
			 result = sqlSession.selectOne(command.getName(), param);
			 if (method.returnsOptional() && (result == null || !method.getReturnType().equals(result.getClass()))) {
				 result = Optional.ofNullable(result);
			 }
		 }
		 break;
	 case FLUSH:
	 	 result = sqlSession.flushStatements();
	 	 break;
	 default:
	 	 throw new BindingException("Unknown execution method for: " + command.getName());
 }
 //è¿”å›ç»“æœä¸º nullï¼Œå¹¶ä¸”è¿”å›ç±»å‹ä¸ºåŸºæœ¬ç±»å‹ï¼Œåˆ™æŠ›å‡º BindingException å¼‚å¸¸
 if(result ==null&&method.getReturnType().isPrimitive() &&!method.returnsVoid()) {
	 throw new BindingException("Mapper method '" + command.getName() + " attempted to return null from a method with a primitive
	 return type(" + method.getReturnType() + "). ");
 }
 //è¿”å›ç»“æœ
 return result;
}
```

## 10.3 â¼†çº§ç·©å­˜æºç¢¼å‰–æï¼š
â¼†ç´šç·©å­˜æ§‹å»ºåœ¨â¼€ç´šç·©å­˜ä¹‹ä¸Šï¼Œåœ¨æ”¶åˆ°æŸ¥è©¢è«‹æ±‚æ™‚ï¼ŒMyBatis â¾¸å…ˆæœƒæŸ¥è©¢â¼†ç´šç·©å­˜ï¼Œè‹¥â¼†ç´šç·©å­˜æœªå‘½ä¸­ï¼Œå†å»æŸ¥è©¢â¼€ç´šç·©å­˜ï¼Œâ¼€ç´šç·©å­˜æ²’æœ‰ï¼Œå†æŸ¥è©¢æ•¸æ“šåº«ã€‚

â¼†ç´šç·©å­˜------ã€‹ â¼€ç´šç·©å­˜------ã€‹æ•¸æ“šåº«

èˆ‡â¼€ç´šç·©å­˜ä¸åŒï¼Œâ¼†ç´šç·©å­˜å’Œå…·é«”çš„å‘½åç©ºé–“ç¶å®šï¼Œâ¼€å€‹ Mapper ä¸­æœ‰â¼€å€‹ Cacheï¼Œç›¸åŒ Mapper ä¸­çš„ MappedStatement å…±â½¤â¼€å€‹ Cacheï¼Œâ¼€ç´šç·©å­˜å‰‡æ˜¯å’Œ SqlSession ç¶å®šã€‚

**å•Ÿâ½¤â¼†ç´šç·©å­˜**

åˆ†ç‚ºä¸‰æ­¥â¾›ï¼š

1ï¼‰é–‹å•Ÿå…¨å±€â¼†ç´šç·©å­˜é…ç½®ï¼š
```xml
<settings>
 <setting name="cacheEnabled" value="true"/>
</settings>
```
2ï¼‰åœ¨éœ€è¦ä½¿â½¤â¼†ç´šç·©å­˜çš„ Mapper é…ç½®â½‚ä»¶ä¸­é…ç½®æ¨™ç±¤
```xml
<cache></cache>
```
3ï¼‰åœ¨å…·é«” CURD æ¨™ç±¤ä¸Šé…ç½® useCache=true
```xml
 <select id="findById" resultType="com.lagou.pojo.User" useCache="true">
 	select * from user where id = #{id}
 </select>
```

**æ¨™ç±¤ < cache/> çš„è§£æ**

æ ¹æ“šä¹‹å‰çš„ mybatis æºç¢¼å‰–æï¼Œxml çš„è§£æâ¼¯ä½œä¸»è¦äº¤çµ¦ XMLConfigBuilder.parse()â½…æ³•ä¾†å¯¦ç¾
```java
// XMLConfigBuilder.parse()
public Configuration parse() {
	if (parsed) {
		throw new BuilderException("Each XMLConfigBuilder can only be used once.");
	}
	parsed = true;
	parseConfiguration(parser.evalNode("/configuration"));// åœ¨è¿™â¾¥
	return configuration;
}
 
// parseConfiguration()
// æ—¢ç„¶æ˜¯åœ¨ xml ä¸­æ·»åŠ çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ç›´æ¥çœ‹å…³äº mappers æ ‡ç­¾çš„è§£æ
private void parseConfiguration(XNode root) {
 try {
	 Properties settings = settingsAsPropertiess(root.evalNode("settings"));
	 propertiesElement(root.evalNode("properties"));
	 loadCustomVfs(settings);
	 typeAliasesElement(root.evalNode("typeAliases"));
	 pluginElement(root.evalNode("plugins"));
	 objectFactoryElement(root.evalNode("objectFactory"));
	 objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
	 reflectionFactoryElement(root.evalNode("reflectionFactory"));
	 settingsElement(settings);
	 // read it after objectFactory and objectWrapperFactory issue #631
	 environmentsElement(root.evalNode("environments"));
	 databaseIdProviderElement(root.evalNode("databaseIdProvider"));
	 typeHandlerElement(root.evalNode("typeHandlers"));
	 // å°±æ˜¯è¿™â¾¥
	 mapperElement(root.evalNode("mappers"));
 } catch (Exception e) {
 	throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
 }
}
// mapperElement()
private void mapperElement(XNode parent) throws Exception {
 if (parent != null) {
 	for (XNode child : parent.getChildren()) {
 		if ("package".equals(child.getName())) {
		 String mapperPackage = child.getStringAttribute("name");
		 configuration.addMappers(mapperPackage);
		} else {
			String resource = child.getStringAttribute("resource");
			String url = child.getStringAttribute("url");
			String mapperClass = child.getStringAttribute("class");
			// æŒ‰ç…§æˆ‘ä»¬æœ¬ä¾‹çš„é…ç½®ï¼Œåˆ™ç›´æ¥â¾›è¯¥ if åˆ¤æ–­
			if (resource != null && url == null && mapperClass == null) {
				ErrorContext.instance().resource(resource);
				InputStream inputStream = Resources.getResourceAsStream(resource);
				XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
				// â½£æˆ XMLMapperBuilderï¼Œå¹¶æ‰§â¾å…¶ parse â½…æ³•
				mapperParser.parse();
			} else if (resource == null && url != null && mapperClass == null) {
				ErrorContext.instance().resource(url);
				InputStream inputStream = Resources.getUrlAsStream(url);
				XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
				mapperParser.parse();
			} else if (resource == null && url == null && mapperClass != null) {
				Class<?> mapperInterface = Resources.classForName(mapperClass);
				configuration.addMapper(mapperInterface);
			} else {
				throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one.");
			}
		}
	}
 }
}
```

æˆ‘å€‘ä¾†çœ‹çœ‹è§£æ Mapper.xml
```java
// XMLMapperBuilder.parse()
public void parse() {
 if (!configuration.isResourceLoaded(resource)) {
	 // è§£æ mapper å±æ€§
	 configurationElement(parser.evalNode("/mapper"));
	 configuration.addLoadedResource(resource);
	 bindMapperForNamespace();
 }
 parsePendingResultMaps();
 parsePendingChacheRefs();
 parsePendingStatements();
}
// configurationElement()
private void configurationElement(XNode context) {
 try {
	 String namespace = context.getStringAttribute("namespace");
	 if (namespace == null || namespace.equals("")) {
	 throw new BuilderException("Mapper's namespace cannot be empty");
	 }
	 builderAssistant.setCurrentNamespace(namespace);
	 cacheRefElement(context.evalNode("cache-ref"));
	 // æœ€ç»ˆåœ¨è¿™â¾¥çœ‹åˆ°äº†å…³äº cache å±æ€§çš„å¤„ç†
	 cacheElement(context.evalNode("cache"));
	 parameterMapElement(context.evalNodes("/mapper/parameterMap"));
	 resultMapElements(context.evalNodes("/mapper/resultMap"));
	 sqlElement(context.evalNodes("/mapper/sql"));
	 // è¿™â¾¥ä¼šå°†â½£æˆçš„ Cache åŒ…è£…åˆ°å¯¹åº”çš„ MappedStatement
	 buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
 } catch (Exception e) {
 	 throw new BuilderException("Error parsing Mapper XML. Cause: " + e, e);
 }
}
// cacheElement()
private void cacheElement(XNode context) throws Exception {
 if (context != null) {
 //è§£æ <cache/> æ ‡ç­¾çš„ type å±æ€§ï¼Œè¿™â¾¥æˆ‘ä»¬å¯ä»¥â¾ƒå®šä¹‰ cache çš„å®ç°ç±»ï¼Œâ½å¦‚ redisCacheï¼Œå¦‚æœæ²¡æœ‰â¾ƒå®šä¹‰ï¼Œè¿™â¾¥ä½¿â½¤å’Œâ¼€çº§ç¼“å­˜ç›¸åŒçš„ PERPETUAL
 String type = context.getStringAttribute("type", "PERPETUAL");
 Class<? extends Cache> typeClass = typeAliasRegistry.resolveAlias(type);
 String eviction = context.getStringAttribute("eviction", "LRU");
 Class<? extends Cache> evictionClass = typeAliasRegistry.resolveAlias(eviction);
 Long flushInterval = context.getLongAttribute("flushInterval");
 Integer size = context.getIntAttribute("size");
 boolean readWrite = !context.getBooleanAttribute("readOnly", false);
 boolean blocking = context.getBooleanAttribute("blocking", false);
 Properties props = context.getChildrenAsProperties();
 // æ„å»º Cache å¯¹è±¡
 builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
 }
}
```

å…ˆä¾†çœ‹çœ‹æ˜¯å¦‚ä½•æ§‹å»º Cache å°è±¡çš„

**MapperBuilderAssistant.useNewCache()**
```java
public Cache useNewCache(Class<? extends Cache> typeClass,
 Class<? extends Cache> evictionClass,
 Long flushInterval,
 Integer size,
 boolean readWrite,
 boolean blocking,
 Properties props) {
	 // 1.â½£æˆ Cache å¯¹è±¡
	 Cache cache = new CacheBuilder(currentNamespace)
	 //è¿™â¾¥å¦‚æœæˆ‘ä»¬å®šä¹‰äº† <cache/> ä¸­çš„ typeï¼Œå°±ä½¿â½¤â¾ƒå®šä¹‰çš„ Cache,å¦åˆ™ä½¿â½¤å’Œâ¼€çº§ç¼“å­˜ç›¸åŒçš„ PerpetualCache
	 .implementation(valueOrDefault(typeClass, PerpetualCache.class))
	 .addDecorator(valueOrDefault(evictionClass, LruCache.class))
	 .clearInterval(flushInterval)
	 .size(size)
	 .readWrite(readWrite)
	 .blocking(blocking)
	 .properties(props)
	 .build();
	 // 2.æ·»åŠ åˆ° Configuration ä¸­
	 configuration.addCache(cache);
	 // 3.å¹¶å°† cache èµ‹å€¼ç»™ MapperBuilderAssistant.currentCache
	 currentCache = cache;
	 return cache;
}
```

æˆ‘å€‘çœ‹åˆ°â¼€å€‹ Mapper.xml åªæœƒè§£æâ¼€æ¬¡æ¨™ç±¤ï¼Œä¹Ÿå°±æ˜¯åªå‰µå»ºâ¼€æ¬¡ Cache å°è±¡ï¼Œæ”¾é€² configuration ä¸­ï¼Œä¸¦å°‡ cache è³¦å€¼çµ¦ MapperBuilderAssistant.currentCache

**buildStatementFromContext(context.evalNodes("select|insert|update|delete"));å°‡ Cache åŒ…è£åˆ° MappedStatement**
```java
// buildStatementFromContext()
private void buildStatementFromContext(List<XNode> list) {
 if (configuration.getDatabaseId() != null) {
 	buildStatementFromContext(list, configuration.getDatabaseId());
 }
 buildStatementFromContext(list, null);
}
//buildStatementFromContext()
private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {
 for (XNode context : list) {
	 final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
	 try {
		// æ¯â¼€æ¡æ‰§â¾è¯­å¥è½¬æ¢æˆâ¼€ä¸ª MappedStatement
		statementParser.parseStatementNode();
	 } catch (IncompleteElementException e) {
		configuration.addIncompleteStatement(statementParser);
	 }
 }
}
// XMLStatementBuilder.parseStatementNode();
public void parseStatementNode() {
 String id = context.getStringAttribute("id");
 String databaseId = context.getStringAttribute("databaseId");
 ...
 Integer fetchSize = context.getIntAttribute("fetchSize");
 Integer timeout = context.getIntAttribute("timeout");
 String parameterMap = context.getStringAttribute("parameterMap");
 String parameterType = context.getStringAttribute("parameterType");
 Class<?> parameterTypeClass = resolveClass(parameterType);
 String resultMap = context.getStringAttribute("resultMap");
 String resultType = context.getStringAttribute("resultType");
 String lang = context.getStringAttribute("lang");
 LanguageDriver langDriver = getLanguageDriver(lang);
 ...
 // åˆ›å»º MappedStatement å¯¹è±¡
 builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
 fetchSize, timeout, parameterMap,parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache,resultOrdered,
 keyGenerator, keyProperty, keyColumn,databaseId, langDriver, resultSets);
}
// builderAssistant.addMappedStatement()
public MappedStatement addMappedStatement(
 String id,
 ...) {
 if (unresolvedCacheRef) {
 	throw new IncompleteElementException("Cache-ref not yet resolved");
 }
 id = applyCurrentNamespace(id, false);
 boolean isSelect = sqlCommandType == SqlCommandType.SELECT;
 //åˆ›å»º MappedStatement å¯¹è±¡
 MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)
 ...
 .flushCacheRequired(valueOrDefault(flushCache, !isSelect))
 .useCache(valueOrDefault(useCache, isSelect))
 .cache(currentCache);// åœ¨è¿™â¾¥å°†ä¹‹å‰â½£æˆçš„ Cache å°è£…åˆ° MappedStatement
 ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);
 if (statementParameterMap != null) {
 	statementBuilder.parameterMap(statementParameterMap);
 }
 MappedStatement statement = statementBuilder.build();
 configuration.addMappedStatement(statement);
 return statement;
}
```

æˆ‘å€‘çœ‹åˆ°å°‡ Mapper ä¸­å‰µå»ºçš„ Cache å°è±¡ï¼ŒåŠ â¼Šåˆ°äº†æ¯å€‹ MappedStatement å°åƒä¸­ï¼Œä¹Ÿå°±æ˜¯åŒâ¼€å€‹ Mapper ä¸­æ‰€æœ‰çš„ 2

æœ‰é—œæ–¼æ¨™ç±¤çš„è§£æå°±åˆ°é€™äº†ã€‚

**æŸ¥è©¢æºç¢¼åˆ†æ**

**CachingExecutor**
```java
// CachingExecutor
public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
 BoundSql boundSql = ms.getBoundSql(parameterObject);
 // åˆ›å»º CacheKey
 CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
 return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
 // ä» MappedStatement ä¸­è·å– Cacheï¼Œæ³¨æ„è¿™â¾¥çš„ Cache æ˜¯ä» MappedStatement ä¸­è·å–çš„
 // ä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¸Šâ¾¯è§£æ Mapper ä¸­ <cache/> æ ‡ç­¾ä¸­åˆ›å»ºçš„ï¼Œå®ƒä¿å­˜åœ¨ Configration ä¸­
 // æˆ‘ä»¬åœ¨ä¸Šâ¾¯è§£æ blog.xml æ—¶åˆ†æè¿‡æ¯â¼€ä¸ª MappedStatement éƒ½æœ‰â¼€ä¸ª Cache å¯¹è±¡ï¼Œå°±æ˜¯è¿™â¾¥
 Cache cache = ms.getCache();
 // å¦‚æœé…ç½®â½‚ä»¶ä¸­æ²¡æœ‰é…ç½® <cache>ï¼Œåˆ™ cache ä¸ºç©º
 if (cache != null) {
	  //å¦‚æœéœ€è¦åˆ·æ–°ç¼“å­˜çš„è¯å°±åˆ·æ–°ï¼šflushCache="true"
	 flushCacheIfRequired(ms);
	 if (ms.isUseCache() && resultHandler == null) {
		 ensureNoOutParams(ms, boundSql);
		 // è®¿é—®â¼†çº§ç¼“å­˜
		 List<E> list = (List<E>) tcm.getObject(cache, key);
		 // ç¼“å­˜æœªå‘½ä¸­
		 if (list == null) {
			 // å¦‚æœæ²¡æœ‰å€¼ï¼Œåˆ™æ‰§â¾æŸ¥è¯¢ï¼Œè¿™ä¸ªæŸ¥è¯¢å®é™…ä¹Ÿæ˜¯å…ˆâ¾›â¼€çº§ç¼“å­˜æŸ¥è¯¢ï¼Œâ¼€çº§ç¼“å­˜ä¹Ÿæ²¡æœ‰çš„è¯ï¼Œåˆ™è¿›â¾ DB æŸ¥è¯¢
			 list = delegate.<E>query(ms, parameterObject, rowBounds, resultHandler,key, boundSql);
			 // ç¼“å­˜æŸ¥è¯¢ç»“æœ
			 tcm.putObject(cache, key, list);
		 }
		 return list;
	 }
 }
 return delegate.<E>query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
```
å¦‚æœè¨­ç½®äº† flushCache="true"ï¼Œå‰‡æ¯æ¬¡æŸ¥è©¢éƒ½æœƒåˆ·æ–°ç·©å­˜
```xml
<!-- æ‰§â¾æ­¤è¯­å¥æ¸…ç©ºç¼“å­˜ -->
<select id="findbyId" resultType="com.lagou.pojo.user" useCache="true"
flushCache="true" >
 select * from t_demo
</select>
```
å¦‚ä¸Šï¼Œæ³¨æ„â¼†ç´šç·©å­˜æ˜¯å¾ MappedStatement ä¸­ç²å–çš„ã€‚ç”±æ–¼ MappedStatement å­˜åœ¨æ–¼å…¨å±€é…ç½®ä¸­ï¼Œå¯ä»¥å¤šå€‹ CachingExecutor ç²å–åˆ°ï¼Œé€™æ¨£å°±æœƒå‡ºç¾ç·šç¨‹å®‰å…¨å•é¡Œã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œè‹¥ä¸åŠ ä»¥æ§åˆ¶ï¼Œå¤šå€‹äº‹å‹™å…±â½¤â¼€å€‹ç·©å­˜å¯¦ä¾‹ï¼Œæœƒå°è‡´è‡Ÿè®€å•é¡Œã€‚ â¾„æ–¼è‡Ÿè®€å•é¡Œï¼Œéœ€è¦è—‰åŠ©å…¶ä»–é¡ä¾†è™•ç†ï¼Œä¹Ÿå°±æ˜¯ä¸Šâ¾¯ä»£ç¢¼ä¸­ tcm è®Šé‡å°æ‡‰çš„é¡å‹ã€‚

ä¸‹â¾¯åˆ†æâ¼€ä¸‹ã€‚

**TransactionalCacheManager**
```java
/** äº‹åŠ¡ç¼“å­˜ç®¡ç†å™¨ */
public class TransactionalCacheManager {
 // Cache ä¸ TransactionalCache çš„æ˜ å°„å…³ç³»è¡¨
 private final Map<Cache, TransactionalCache> transactionalCaches = new HashMap<Cache, TransactionalCache>();
 public void clear(Cache cache) {
	 // è·å– TransactionalCache å¯¹è±¡ï¼Œå¹¶è°ƒâ½¤è¯¥å¯¹è±¡çš„ clear â½…æ³•ï¼Œä¸‹åŒ
	 getTransactionalCache(cache).clear();
 }
 public Object getObject(Cache cache, CacheKey key) {
	 // ç›´æ¥ä» TransactionalCache ä¸­è·å–ç¼“å­˜
	 return getTransactionalCache(cache).getObject(key);
 }
 public void putObject(Cache cache, CacheKey key, Object value) {
	 // ç›´æ¥å­˜â¼Š TransactionalCache çš„ç¼“å­˜ä¸­
	 getTransactionalCache(cache).putObject(key, value);
 }
 public void commit() {
	 for (TransactionalCache txCache : transactionalCaches.values()) {
	 	txCache.commit();
	 }
 }
 public void rollback() {
	 for (TransactionalCache txCache : transactionalCaches.values()) {
	 	txCache.rollback();
	 }
 }
 private TransactionalCache getTransactionalCache(Cache cache) {
	 // ä»æ˜ å°„è¡¨ä¸­è·å– TransactionalCache
	 TransactionalCache txCache = transactionalCaches.get(cache);
	 if (txCache == null) {
		 // TransactionalCache ä¹Ÿæ˜¯â¼€ç§è£…é¥°ç±»ï¼Œä¸º Cache å¢åŠ äº‹åŠ¡åŠŸèƒ½
		 // åˆ›å»ºâ¼€ä¸ªæ–°çš„ TransactionalCacheï¼Œå¹¶å°†çœŸæ­£çš„ Cache å¯¹è±¡å­˜è¿›å»
		 txCache = new TransactionalCache(cache);
		 transactionalCaches.put(cache, txCache);
	 }
	 return txCache;
 }
}
```

TransactionalCacheManager å…§éƒ¨ç¶­è­·äº† Cache å¯¦ä¾‹èˆ‡ TransactionalCache å¯¦ä¾‹é–“çš„æ˜ å°„é—œä¿‚ï¼Œè©²é¡ä¹Ÿåƒ…è² è²¬ç¶­è­·å…©è€…çš„æ˜ å°„é—œä¿‚ï¼ŒçœŸæ­£åšäº‹çš„é‚„æ˜¯ TransactionalCacheã€‚ 

TransactionalCache æ˜¯â¼€ç¨®ç·©å­˜è£é£¾å™¨ï¼Œå¯ä»¥ç‚º Cache å¯¦ä¾‹å¢åŠ äº‹å‹™åŠŸèƒ½ã€‚

æˆ‘åœ¨ä¹‹å‰æåˆ°çš„é«’è®€å•é¡Œæ­£æ˜¯ç”±è©²é¡é€²â¾è™•ç†çš„ã€‚ä¸‹â¾¯åˆ†æâ¼€ä¸‹è©²é¡çš„é‚è¼¯ã€‚

**TransactionalCache**
```java
public class TransactionalCache implements Cache {
 //çœŸæ­£çš„ç¼“å­˜å¯¹è±¡ï¼Œå’Œä¸Šâ¾¯çš„ Map<Cache, TransactionalCache> ä¸­çš„ Cache æ˜¯åŒâ¼€ä¸ª
 private final Cache delegate;
 private boolean clearOnCommit;
 // åœ¨äº‹åŠ¡è¢«æäº¤å‰ï¼Œæ‰€æœ‰ä»æ•°æ®åº“ä¸­æŸ¥è¯¢çš„ç»“æœå°†ç¼“å­˜åœ¨æ­¤é›†åˆä¸­
 private final Map<Object, Object> entriesToAddOnCommit;
 // åœ¨äº‹åŠ¡è¢«æäº¤å‰ï¼Œå½“ç¼“å­˜æœªå‘½ä¸­æ—¶ï¼ŒCacheKey å°†ä¼šè¢«å­˜å‚¨åœ¨æ­¤é›†åˆä¸­
 private final Set<Object> entriesMissedInCache;
 @Override
 public Object getObject(Object key) {
	 // æŸ¥è¯¢çš„æ—¶å€™æ˜¯ç›´æ¥ä» delegate ä¸­å»æŸ¥è¯¢çš„ï¼Œä¹Ÿå°±æ˜¯ä»çœŸæ­£çš„ç¼“å­˜å¯¹è±¡ä¸­æŸ¥è¯¢
	 Object object = delegate.getObject(key);
	 if (object == null) {
		 // ç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ™å°† key å­˜â¼Šåˆ° entriesMissedInCache ä¸­
		 entriesMissedInCache.add(key);
	 }
	 if (clearOnCommit) {
	 	return null;
	 } else {
	 	return object;
	 }
 }
 @Override
 public void putObject(Object key, Object object) {
	 // å°†é”®å€¼å¯¹å­˜â¼Šåˆ° entriesToAddOnCommit è¿™ä¸ª Map ä¸­ä¸­ï¼Œâ½½â¾®çœŸå®çš„ç¼“å­˜å¯¹è±¡ delegate ä¸­
	 entriesToAddOnCommit.put(key, object);
 }
 @Override
 public Object removeObject(Object key) {
 	return null;
 }
 @Override
 public void clear() {
	 clearOnCommit = true;
	 // æ¸…ç©º entriesToAddOnCommitï¼Œä½†ä¸æ¸…ç©º delegate ç¼“å­˜
	 entriesToAddOnCommit.clear();
 }
 public void commit() {
	 // æ ¹æ® clearOnCommit çš„å€¼å†³å®šæ˜¯å¦æ¸…ç©º delegate
	 if (clearOnCommit) {
	 	delegate.clear();
 	 }
	 // åˆ·æ–°æœªç¼“å­˜çš„ç»“æœåˆ° delegate ç¼“å­˜ä¸­
	 flushPendingEntries();
	 // é‡ç½® entriesToAddOnCommit å’Œ entriesMissedInCache
	 reset();
 }
 public void rollback() {
	 unlockMissedEntries();
	 reset();
 }
 private void reset() {
	 clearOnCommit = false;
	 // æ¸…ç©ºé›†åˆ
	 entriesToAddOnCommit.clear();
	 entriesMissedInCache.clear();
 }
 private void flushPendingEntries() {
	 for (Map.Entry<Object, Object> entry : entriesToAddOnCommit.entrySet()) {
		 // å°† entriesToAddOnCommit ä¸­çš„å†…å®¹è½¬å­˜åˆ° delegate ä¸­
		 delegate.putObject(entry.getKey(), entry.getValue());
	 }
	 for (Object entry : entriesMissedInCache) {
		 if (!entriesToAddOnCommit.containsKey(entry)) {
		 // å­˜â¼Šç©ºå€¼
		 delegate.putObject(entry, null);
		 }
	 }
 }
 private void unlockMissedEntries() {
	 for (Object entry : entriesMissedInCache) {
		 try {
			 // è°ƒâ½¤ removeObject è¿›â¾è§£é”
			 delegate.removeObject(entry);
		 } catch (Exception e) {
		 	 log.warn("...");
		 }
	 }
 }
}
```
å­˜å„²â¼†ç´šç·©å­˜å°è±¡çš„æ™‚å€™æ˜¯æ”¾åˆ°äº† TransactionalCache.entriesToAddOnCommit é€™å€‹ map ä¸­ï¼Œä½†æ˜¯æ¯æ¬¡æŸ¥è©¢çš„æ™‚å€™æ˜¯ç›´æ¥å¾ TransactionalCache.delegate ä¸­å»æŸ¥è©¢çš„ï¼Œ

æ‰€ä»¥é€™å€‹â¼†ç´šç·©å­˜æŸ¥è©¢æ•¸æ“šåº«å¾Œï¼Œè¨­ç½®ç·©å­˜å€¼æ˜¯æ²’æœ‰â½´åˆ»â½£æ•ˆçš„ï¼Œä¸»è¦æ˜¯å› ç‚ºç›´æ¥å­˜åˆ° delegate æœƒå°è‡´è‡Ÿæ•¸æ“šå•é¡Œ

**ç‚ºä½•åªæœ‰ SqlSession æäº¤æˆ–é—œé–‰ä¹‹å¾Œï¼Ÿ**

é‚£æˆ‘å€‘ä¾†çœ‹ä¸‹ SqlSession.commit()â½…æ³•åšäº†ä»€éº¼

SqlSession
```java
@Override
public void commit(boolean force) {
 try {
	 // ä¸»è¦æ˜¯è¿™å¥
	 executor.commit(isCommitOrRollbackRequired(force));
	 dirty = false;
 } catch (Exception e) {
 	 throw ExceptionFactory.wrapException("Error committing transaction. Cause: " + e, e);
 } finally {
 	 ErrorContext.instance().reset();
 }
}
// CachingExecutor.commit()
@Override
public void commit(boolean required) throws SQLException {
 delegate.commit(required);
 tcm.commit();// åœ¨è¿™â¾¥
}
// TransactionalCacheManager.commit()
public void commit() {
 for (TransactionalCache txCache : transactionalCaches.values()) {
 	 txCache.commit();// åœ¨è¿™â¾¥
 }
}
// TransactionalCache.commit()
public void commit() {
 if (clearOnCommit) {
 	 delegate.clear();
 }
 flushPendingEntries();//è¿™â¼€å¥
 reset();
}
// TransactionalCache.flushPendingEntries()
private void flushPendingEntries() {
 for (Map.Entry<Object, Object> entry : entriesToAddOnCommit.entrySet()) {
	 // åœ¨è¿™â¾¥çœŸæ­£çš„å°† entriesToAddOnCommit çš„å¯¹è±¡é€ä¸ªæ·»åŠ åˆ° delegate ä¸­ï¼Œåªæœ‰è¿™æ—¶ï¼Œâ¼†çº§ç¼“å­˜æ‰çœŸæ­£çš„â½£æ•ˆ
	 delegate.putObject(entry.getKey(), entry.getValue());
 }
 for (Object entry : entriesMissedInCache) {
	 if (!entriesToAddOnCommit.containsKey(entry)) {
	 	 delegate.putObject(entry, null);
	 }
 }
}
```

**â¼†ç´šç·©å­˜çš„åˆ·æ–°**

æˆ‘å€‘ä¾†çœ‹çœ‹ SqlSession çš„æ›´æ–°æ“ä½œ
```java
public int update(String statement, Object parameter) {
 int var4;
 try {
	 this.dirty = true;
	 MappedStatement ms = this.configuration.getMappedStatement(statement);
	 var4 = this.executor.update(ms, this.wrapCollection(parameter));
 } catch (Exception var8) {
 	 throw ExceptionFactory.wrapException("Error updating database. Cause: " + var8, var8);
 } finally {
 	 ErrorContext.instance().reset();
 }
 return var4;
}
public int update(MappedStatement ms, Object parameterObject) throws SQLException {
 this.flushCacheIfRequired(ms);
 return this.delegate.update(ms, parameterObject);
}
private void flushCacheIfRequired(MappedStatement ms) {
 //è·å– MappedStatement å¯¹åº”çš„ Cacheï¼Œè¿›â¾æ¸…ç©º
 Cache cache = ms.getCache();
 //SQL éœ€è®¾ç½® flushCache="true" æ‰ä¼šæ‰§â¾æ¸…ç©º
 if (cache != null && ms.isFlushCacheRequired()) {
 	 this.tcm.clear(cache);
 }
}
```

MyBatis â¼†ç´šç·©å­˜åªé©â½¤æ–¼ä¸å¸¸é€²â¾å¢ã€åˆªã€æ”¹çš„æ•¸æ“šï¼Œâ½å¦‚åœ‹å®¶â¾æ”¿å€çœå¸‚å€è¡—é“æ•¸æ“šã€‚ â¼€ä½†æ•¸æ“šè®Šæ›´ï¼ŒMyBatis æœƒæ¸…ç©ºç·©å­˜ã€‚å› æ­¤â¼†ç´šç·©å­˜ä¸é©â½¤æ–¼ç¶“å¸¸é€²â¾æ›´æ–°çš„æ•¸æ“šã€‚

**ç¸½çµï¼š**

åœ¨â¼†ç´šç·©å­˜çš„è¨­è¨ˆä¸Šï¼ŒMyBatis â¼¤é‡åœ°é‹â½¤äº†è£é£¾è€…æ¨¡å¼ï¼Œå¦‚ CachingExecutor, ä»¥åŠå„ç¨® Cache æ¥â¼çš„è£é£¾å™¨ã€‚

- â¼†ç´šç·©å­˜å¯¦ç¾äº† Sqlsession ä¹‹é–“çš„ç·©å­˜æ•¸æ“šå…±äº«ï¼Œå±¬æ–¼ namespace ç´šåˆ¥
- â¼†ç´šç·©å­˜å…·æœ‰è±å¯Œçš„ç·©å­˜ç­–ç•¥ã€‚
- â¼†ç´šç·©å­˜å¯ç”±å¤šå€‹è£é£¾å™¨ï¼Œèˆ‡åŸºç¤ç·©å­˜çµ„åˆâ½½æˆ
- â¼†ç´šç·©å­˜â¼¯ä½œç”± â¼€å€‹ç·©å­˜è£é£¾åŸ·â¾å™¨ CachingExecutor å’Œ â¼€å€‹äº‹å‹™å‹é ç·©å­˜ TransactionalCache å®Œæˆã€‚


  
## 10.4 å»¶é²åŠ è¼‰æºç¢¼å‰–æï¼š

**ä»€ä¹ˆæ˜¯å»¶é²åŠ è¼‰ï¼Ÿ**

**å•é¡Œ**

 åœ¨é–‹ç™¼éç¨‹ä¸­å¾ˆå¤šæ™‚å€™æˆ‘å€‘ä¸¦ä¸éœ€è¦ç¸½æ˜¯åœ¨åŠ è¼‰â½¤æˆ¶ä¿¡æ¯æ™‚å°±â¼€å®šè¦åŠ è¼‰ä»–çš„è¨‚å–®ä¿¡æ¯ã€‚æ­¤æ™‚å°±æ˜¯æˆ‘å€‘æ‰€èªªçš„å»¶é²åŠ è¼‰ã€‚
 
èˆ‰å€‹æ —â¼¦

	åœ¨â¼€å°å¤šä¸­ï¼Œç•¶æˆ‘å€‘æœ‰â¼€å€‹â½¤æˆ¶ï¼Œå®ƒæœ‰å€‹ 100 å€‹è¨‚å–®
	 åœ¨æŸ¥è©¢â½¤æˆ¶çš„æ™‚å€™ï¼Œè¦ä¸è¦æŠŠé—œè¯çš„è¨‚å–®æŸ¥å‡ºä¾†ï¼Ÿ
	 åœ¨æŸ¥è©¢è¨‚å–®çš„æ™‚å€™ï¼Œè¦ä¸è¦æŠŠé—œè¯çš„â½¤æˆ¶æŸ¥å‡ºä¾†ï¼Ÿ
	 
	å›ç­”
	 åœ¨æŸ¥è©¢â½¤æˆ¶æ™‚ï¼Œâ½¤æˆ¶ä¸‹çš„è¨‚å–®æ‡‰è©²æ˜¯ï¼Œä»€éº¼æ™‚å€™â½¤ï¼Œä»€éº¼æ™‚å€™æŸ¥è©¢ã€‚
	 åœ¨æŸ¥è©¢è¨‚å–®æ™‚ï¼Œè¨‚å–®æ‰€å±¬çš„â½¤æˆ¶ä¿¡æ¯æ‡‰è©²æ˜¯éš¨è‘—è¨‚å–®â¼€èµ·æŸ¥è©¢å‡ºä¾†ã€‚
	 
	 
 **å»¶é²åŠ è¼‰**
å°±æ˜¯åœ¨éœ€è¦â½¤åˆ°æ•¸æ“šæ™‚æ‰é€²â¾åŠ è¼‰ï¼Œä¸éœ€è¦â½¤åˆ°æ•¸æ“šæ™‚å°±ä¸åŠ è¼‰æ•¸æ“šã€‚å»¶é²åŠ è¼‰ä¹Ÿç¨±æ‡¶åŠ è¼‰ã€‚

* å„ªé»ï¼š
 å…ˆå¾å–®è¡¨æŸ¥è©¢ï¼Œéœ€è¦æ™‚å†å¾é—œè¯è¡¨å»é—œè¯æŸ¥è©¢ï¼Œâ¼¤â¼¤æâ¾¼æ•¸æ“šåº«æ€§èƒ½ï¼Œå› ç‚ºæŸ¥è©¢å–®è¡¨è¦â½é—œè¯æŸ¥è©¢å¤šå¼µè¡¨é€Ÿåº¦è¦å¿«ã€‚
 
* ç¼ºé»ï¼š
 å› ç‚ºåªæœ‰ç•¶éœ€è¦â½¤åˆ°æ•¸æ“šæ™‚ï¼Œæ‰æœƒé€²â¾æ•¸æ“šåº«æŸ¥è©¢ï¼Œé€™æ¨£åœ¨â¼¤æ‰¹é‡æ•¸æ“šæŸ¥è©¢æ™‚ï¼Œå› ç‚ºæŸ¥è©¢â¼¯ä½œä¹Ÿè¦æ¶ˆè€—æ™‚é–“ï¼Œæ‰€ä»¥å¯
èƒ½é€ æˆâ½¤æˆ¶ç­‰å¾…æ™‚é–“è®Šâ»“ï¼Œé€ æˆâ½¤æˆ¶é«”é©—ä¸‹é™ã€‚
 
* åœ¨å¤šè¡¨ä¸­ï¼š
 â¼€å°å¤šï¼Œå¤šå°å¤šï¼šé€šå¸¸æƒ…æ³ä¸‹æ¡â½¤å»¶é²åŠ è¼‰
 â¼€å°â¼€ï¼ˆå¤šå°â¼€ï¼‰ï¼šé€šå¸¸æƒ…æ³ä¸‹æ¡â½¤â½´å³åŠ è¼‰
 
* æ³¨æ„ï¼š
 å»¶é²åŠ è¼‰æ˜¯åŸºæ–¼åµŒå¥—æŸ¥è©¢ä¾†å¯¦ç¾çš„

**å¯¦ç¾**

**å±€éƒ¨å»¶é²åŠ è¼‰**

åœ¨ association å’Œ collection æ¨™ç±¤ä¸­éƒ½æœ‰â¼€å€‹ fetchType å±¬æ€§ï¼Œé€šéä¿®æ”¹å®ƒçš„å€¼ï¼Œå¯ä»¥ä¿®æ”¹å±€éƒ¨çš„åŠ è¼‰ç­–ç•¥ã€‚
```xml
<!-- å¼€å¯â¼€å¯¹å¤š å»¶è¿ŸåŠ è½½ -->
<resultMap id="userMap" type="user">
 <id column="id" property="id"></id>
 <result column="username" property="username"></result>
 <result column="password" property="password"></result>
 <result column="birthday" property="birthday"></result>
 <!--
 fetchType="lazy" æ‡’åŠ è½½ç­–ç•¥
 fetchType="eager" â½´å³åŠ è½½ç­–ç•¥
 -->
 <collection property="orderList" ofType="order" column="id" 
 select="com.lagou.dao.OrderMapper.findByUid" fetchType="lazy">
 </collection>
</resultMap>
<select id="findAll" resultMap="userMap">
 SELECT * FROM `user`
</select>
```

**å…¨å±€å»¶é²åŠ è¼‰**

åœ¨ Mybatis çš„æ ¸â¼¼é…ç½®â½‚ä»¶ä¸­å¯ä»¥ä½¿â½¤ setting æ¨™ç±¤ä¿®æ”¹å…¨å±€çš„åŠ è¼‰ç­–ç•¥ã€‚
```xml
<settings>
 <!--å¼€å¯å…¨å±€å»¶è¿ŸåŠ è½½åŠŸèƒ½-->
 <setting name="lazyLoadingEnabled" value="true"/>
</settings>
```

**æ³¨æ„**
```xml
<!-- å…³é—­â¼€å¯¹â¼€ å»¶è¿ŸåŠ è½½ -->
<resultMap id="orderMap" type="order">
 <id column="id" property="id"></id>
 <result column="ordertime" property="ordertime"></result>
 <result column="total" property="total"></result>
 <!--
 fetchType="lazy" æ‡’åŠ è½½ç­–ç•¥
 fetchType="eager" â½´å³åŠ è½½ç­–ç•¥
 -->
 <association property="user" column="uid" javaType="user"
 select="com.lagou.dao.UserMapper.findById" fetchType="eager"> 
</association>
</resultMap>
<select id="findAll" resultMap="orderMap">
 SELECT * from orders
</select>

```

**å»¶é²åŠ è¼‰åŸç†å¯¦ç¾**
å®ƒçš„åŸç†æ˜¯ï¼Œä½¿â½¤ CGLIB æˆ– Javassist( é»˜èª ) å‰µå»ºâ½¬æ¨™å°è±¡çš„ä»£ç†å°è±¡ã€‚ç•¶èª¿â½¤ä»£ç†å°è±¡çš„å»¶é²åŠ è¼‰å±¬æ€§çš„ getting â½…æ³•æ™‚ï¼Œé€²â¼Šæ””æˆªå™¨â½…æ³•ã€‚

â½å¦‚èª¿â½¤ a.getB().getName() â½…æ³•ï¼Œé€²â¼Šæ””æˆªå™¨çš„ invoke(...) â½…æ³•ï¼Œç™¼ç¾ a.getB() éœ€è¦å»¶é²åŠ è¼‰æ™‚ï¼Œé‚£éº¼å°±æœƒå–®ç¨ç™¼é€äº‹å…ˆä¿å­˜å¥½çš„æŸ¥è©¢é—œè¯ B å°è±¡çš„ SQL ï¼ŒæŠŠ B æŸ¥è©¢ä¸Šä¾†ï¼Œç„¶å¾Œèª¿â½¤ a.setB(b) â½…æ³•ï¼Œæ–¼æ˜¯ a å°è±¡ b å±¬æ€§å°±æœ‰å€¼äº†ï¼Œæ¥è‘—å®Œæˆ a.getB().getName() â½…æ³•çš„èª¿â½¤ã€‚é€™å°±æ˜¯å»¶é²åŠ è¼‰çš„åŸºæœ¬åŸç†

ç¸½çµï¼šå»¶é²åŠ è¼‰ä¸»è¦æ˜¯é€šéå‹•æ…‹ä»£ç†çš„å½¢å¼å¯¦ç¾ï¼Œé€šéä»£ç†æ””æˆªåˆ°æŒ‡å®šâ½…æ³•ï¼ŒåŸ·â¾æ•¸æ“šåŠ è¼‰ã€‚

**å»¶é²åŠ è¼‰åŸç†ï¼ˆæºç¢¼å‰–æ)**

MyBatis å»¶é²åŠ è¼‰ä¸»è¦ä½¿â½¤ï¼šJavassistï¼ŒCglib å¯¦ç¾ï¼Œé¡åœ–å±•ç¤ºï¼š
![[Pasted image 20211003162023.png]]

**Setting é…ç½®åŠ è½½ï¼š**
```java
public class Configuration {
/** aggressiveLazyLoadingï¼š
 * ç•¶é–‹å•Ÿæ™‚ï¼Œä»»ä½•â½…æ³•çš„èª¿â½¤éƒ½æœƒåŠ è¼‰è©²å°è±¡çš„æ‰€æœ‰å±¬æ€§ã€‚å¦å‰‡ï¼Œæ¯å€‹å±¬æ€§æœƒæŒ‰éœ€åŠ è¼‰ï¼ˆåƒè€ƒ lazyLoadTriggerMethods).
 * é»˜èªç‚º true
 * */
 protected boolean aggressiveLazyLoading;
 /**
 * å»¶é²åŠ è¼‰è§¸ç™¼â½…æ³•
 */
 protected Set<String> lazyLoadTriggerMethods = new HashSet<String>(Arrays.asList(new String[] { "equals", "clone", "hashCode", "toString" }));
 /** æ˜¯å¦é–‹å•Ÿå»¶é²åŠ è¼‰ */
 protected boolean lazyLoadingEnabled = false;
 
 /**
 * é»˜èªä½¿â½¤ Javassist ä»£ç†â¼¯â¼š
 * @param proxyFactory
 */
 public void setProxyFactory(ProxyFactory proxyFactory) {
	 if (proxyFactory == null) {
	 	 proxyFactory = new JavassistProxyFactory();
	 }
	 this.proxyFactory = proxyFactory;
 }
 
 //çœç•¥...
}
```

**å»¶é²åŠ è¼‰ä»£ç†å°è±¡å‰µå»º**

 Mybatis çš„æŸ¥è©¢çµæœæ˜¯ç”± ResultSetHandler æ¥â¼çš„ handleResultSets()â½…æ³•è™•ç†çš„ã€‚ 
 
 ResultSetHandler æ¥â¼åªæœ‰â¼€å€‹å¯¦ç¾ï¼ŒDefaultResultSetHandlerï¼Œæ¥ä¸‹ä¾†çœ‹ä¸‹å»¶é²åŠ è¼‰ç›¸é—œçš„â¼€å€‹æ ¸â¼¼çš„â½…æ³•
```java
<code class="language-Java">//#mark åˆ›å»ºç»“æœå¯¹è±¡
 private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {
	 this.useConstructorMappings = false; // reset previous mapping result
	 final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;Class&lt;?&gt;&gt;();
	 final List&lt;Object&gt; constructorArgs = new ArrayList&lt;Object&gt;();
	 //#mark åˆ›å»ºè¿”å›çš„ç»“æœæ˜ å°„çš„çœŸå®å¯¹è±¡
	 Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);
	 if (resultObject != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {
		  final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();
		  for (ResultMapping propertyMapping : propertyMappings) {
				 // åˆ¤æ–­å±æ€§æœ‰æ²¡é…ç½®åµŒå¥—æŸ¥è¯¢ï¼Œå¦‚æœæœ‰å°±åˆ›å»ºä»£ç†å¯¹è±¡
				 if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) {
					  //#mark åˆ›å»ºå»¶è¿ŸåŠ è½½ä»£ç†å¯¹è±¡
					  resultObject = configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);
					  break;
					  }
				 }
		  }
	 this.useConstructorMappings = resultObject != null &amp;&amp; !constructorArgTypes.isEmpty(); // set current mapping result
	 return resultObject;
 }
```
é»˜èªæ¡â½¤ javassistProxy é€²â¾ä»£ç†å°è±¡çš„å‰µå»º
![[Pasted image 20211003162537.png]]

JavasisstProxyFactory å¯¦ç¾
```java
public class JavassistProxyFactory implements
org.apache.ibatis.executor.loader.ProxyFactory {
 
 /**
 * æ¥â¼å®ç°
 * @param target â½¬æ ‡ç»“æœå¯¹è±¡
 * @param lazyLoader å»¶è¿ŸåŠ è½½å¯¹è±¡
 * @param configuration é…ç½®
 * @param objectFactory å¯¹è±¡â¼¯â¼š
 * @param constructorArgTypes æ„é€ å‚æ•°ç±»å‹
 * @param constructorArgs æ„é€ å‚æ•°å€¼
 * @return
 */
 @Override
 public Object createProxy(Object target, ResultLoaderMap lazyLoader, Configuration
configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt;
constructorArgTypes, List&lt;Object&gt; constructorArgs) {
 return EnhancedResultObjectProxyImpl.createProxy(target, lazyLoader, configuration,
objectFactory, constructorArgTypes, constructorArgs);
 }
 //çœç•¥...
 
 /**
 * ä»£ç†å¯¹è±¡å®ç°ï¼Œæ ¸â¼¼é€»è¾‘æ‰§â¾
 */
 private static class EnhancedResultObjectProxyImpl implements MethodHandler {
 
 /**
 * åˆ›å»ºä»£ç†å¯¹è±¡
 * @param type
 * @param callback
 * @param constructorArgTypes
 * @param constructorArgs
 * @return
 */
 static Object crateProxy(Class&lt;?&gt; type, MethodHandler callback,
List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {
 ProxyFactory enhancer = new ProxyFactory();
 enhancer.setSuperclass(type);
 try {
 //é€šè¿‡è·å–å¯¹è±¡â½…æ³•ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨è¯¥â½…æ³•
 type.getDeclaredMethod(WRITE_REPLACE_METHOD);
 // ObjectOutputStream will call writeReplace of objects returned by writeReplace
 if (log.isDebugEnabled()) {
 log.debug(WRITE_REPLACE_METHOD + &quot; method was found on bean &quot; + type
+ &quot;, make sure it returns this&quot;);
 }
 } catch (NoSuchMethodException e) {
 //æ²¡æ‰¾åˆ°è¯¥â½…æ³•ï¼Œå®ç°æ¥â¼
 enhancer.setInterfaces(new Class[]{WriteReplaceInterface.class});
 } catch (SecurityException e) {
 // nothing to do here
 }
 Object enhanced;
 Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(new
Class[constructorArgTypes.size()]);
 Object[] valuesArray = constructorArgs.toArray(new Object[constructorArgs.size()]);
 try {
 //åˆ›å»ºæ–°çš„ä»£ç†å¯¹è±¡
 enhanced = enhancer.create(typesArray, valuesArray);
 } catch (Exception e) {
 throw new ExecutorException(&quot;Error creating lazy proxy. Cause: &quot; + e,
e);
 }
 //è®¾ç½®ä»£ç†æ‰§â¾å™¨
 ((Proxy) enhanced).setHandler(callback);
 return enhanced;
 }
 
 
 /**
 * ä»£ç†å¯¹è±¡æ‰§â¾
 * @param enhanced åŸå¯¹è±¡
 * @param method åŸå¯¹è±¡â½…æ³•
 * @param methodProxy ä»£ç†â½…æ³•
 * @param args â½…æ³•å‚æ•°
 * @return
 * @throws Throwable
 */
 @Override
 public Object invoke(Object enhanced, Method method, Method methodProxy, Object[]
args) throws Throwable {
 final String methodName = method.getName();
 try {
 synchronized (lazyLoader) {
 if (WRITE_REPLACE_METHOD.equals(methodName)) {
 //å¿½ç•¥æš‚æœªæ‰¾åˆ°å…·ä½“ä½œâ½¤
 Object original;
 if (constructorArgTypes.isEmpty()) {
 original = objectFactory.create(type);
 } else {
 original = objectFactory.create(type, constructorArgTypes,
constructorArgs);
 }
 PropertyCopier.copyBeanProperties(type, enhanced, original);
 if (lazyLoader.size() &gt; 0) {
 return new JavassistSerialStateHolder(original,
lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);
 } else {
 return original;
 }
 } else {
 //å»¶è¿ŸåŠ è½½æ•°é‡â¼¤äº 0
 if (lazyLoader.size() &gt; 0 &amp;&amp;
!FINALIZE_METHOD.equals(methodName)) {
 //aggressive â¼€æ¬¡åŠ è½½æ€§æ‰€æœ‰éœ€è¦è¦å»¶è¿ŸåŠ è½½å±æ€§æˆ–è€…åŒ…å«è§¦å‘å»¶è¿ŸåŠ è½½â½…æ³•
 if (aggressive || lazyLoadTriggerMethods.contains(methodName)) {
 log.debug(&quot;==&gt; laze lod trigger method:&quot; + methodName +
&quot;,proxy method:&quot; + methodProxy.getName() + &quot; class:&quot; +
enhanced.getClass());
 //â¼€æ¬¡å…¨éƒ¨åŠ è½½
 lazyLoader.loadAll();
 } else if (PropertyNamer.isSetter(methodName)) {
 //åˆ¤æ–­æ˜¯å¦ä¸º set â½…æ³•ï¼Œset â½…æ³•ä¸éœ€è¦å»¶è¿ŸåŠ è½½
 final String property = PropertyNamer.methodToProperty(methodName);
 lazyLoader.remove(property);
 } else if (PropertyNamer.isGetter(methodName)) {
 final String property = PropertyNamer.methodToProperty(methodName);
 if (lazyLoader.hasLoader(property)) {
 //å»¶è¿ŸåŠ è½½å•ä¸ªå±æ€§
 lazyLoader.load(property);
 log.debug(&quot;load one :&quot; + methodName);
 }
 }
 }
 }
 }
 return methodProxy.invoke(enhanced, args);
 } catch (Throwable t) {
 throw ExceptionUtil.unwrapThrowable(t);
 }
 }
 }
```

**æ³¨æ„äº‹é …**

IDEA èª¿è©¦å•é¡Œ 

	ç•¶é…ç½® aggressiveLazyLoading=trueï¼Œåœ¨ä½¿â½¤ IDEA é€²â¾èª¿è©¦çš„æ™‚å€™ï¼Œå¦‚æœæ–·é»æ‰“åˆ°ä»£ç†åŸ·â¾é‚è¼¯ç•¶ä¸­ï¼Œä½ æœƒç™¼ç¾å»¶é²åŠ è¼‰çš„ä»£ç¢¼æ°¸é éƒ½ä¸èƒ½é€²â¼Šï¼Œç¸½æ˜¯æœƒè¢«æå‰åŸ·â¾ã€‚
	ä¸»è¦ç”¢â½£çš„åŸå› åœ¨ aggressiveLazyLoadingï¼Œå› ç‚ºåœ¨èª¿è©¦çš„æ™‚å€™ï¼ŒIDEA çš„ Debuger çª—é«”ä¸­å·²ç¶“è§¸ç™¼äº†å»¶é²åŠ è¼‰å°è±¡çš„â½…æ³•ã€‚



